[[chapter-4]]
= Angular Deployment

One of the more popular combinations of frontend and backend frameworks is Angular + Spring Boot. It's possible to combine the two—from keeping them as separate apps to combining them into a single artifact. But, what about deployment?

Developers ask me from time to time, "`What's the best way to do Angular deployment?`" In this section, I'll show you several options. I'll start by showing you how to deploy a Spring Boot app to Heroku. Then, I'll show how to deploy a separate Angular app to Heroku.

There are lots of tutorials and information in the Java community on how to deploy Spring Boot apps, so I'll leave the Spring Boot API on Heroku and show other Angular deployment options, including Firebase, Netlify, and AWS S3.

[[angular-deployment-with-spring-boot]]
.Angular Deployment with a Side of Spring Boot
image::../images/angular-deployment/angular-deployment.png[Angular Deployment with a Side of Spring Boot, 800, scaledwidth="100%"]

== Create an Angular + Spring Boot App

If you're following along, you should have an `angular-bootstrap` directory with an Angular and a Spring Boot app in it. It's a note-taking app that uses Kotlin and Spring Boot on the backend and Angular on the frontend. It's secured with OpenID Connect (OIDC).

If you'd rather start from this point, download the examples for this book from InfoQ. The `angular-bootstrap` directory has the previous section's completed example. Copy it to `angular-deployment` in your favorite code location.

One of the slick features of this app is its full-featured data table that allows sorting, searching, and pagination. This feature is powered by NG Bootstrap and Spring Data JPA. Below is a screenshot:

[[notes-list-with-sorting-recap]]
.Notes list with sorting
image::../images/angular-bootstrap/notes-list-with-sorting.png[Notes list with sorting, 800, scaledwidth="100%"]

=== Secure Your Angular + Spring Boot App with OIDC

To begin, you'll need to https://signup.heroku.com/login[create a Heroku account]. If you already have a Heroku account, https://id.heroku.com/login[log in to it]. Once you're logged in, create a new app. I named mine `bootiful-angular`.

[[heroku-create-app]]
.Create Heroku app
image::../images/angular-deployment/heroku-create-app.png[Create Heroku app, 700, scaledwidth="100%"]

After creating your app, click on the **Resources** tab and add the **Okta** add-on.

[[okta-add-on]]
.Okta Add-On
image::../images/angular-deployment/okta-add-on.png[Okta Add-On, 450, scaledwidth="100%"]

CAUTION: If you haven't entered a credit card for your Heroku account, you will receive an error. This is because Heroku requires you to have a credit card on file to use any of their add-ons, even for free ones. This is part of Heroku's assurance to guard against misuse (real person, real credit card, etc.). I think this is a good security practice. Simply add a credit card to continue.

Click **Submit Order Form** and wait 20-30 seconds while your Okta account is created and OIDC apps are registered. Now, go to your app's **Settings** tab and click the **Reveal Config Vars** button. The Config Vars displayed are the environment variables you can use to configure both Angular and Spring Boot for OIDC authentication.

[[heroku-config-vars]]
.Okta Add-On
image::../images/angular-deployment/heroku-config-vars.png[Okta Add-On, 800, scaledwidth="100%"]

.What if I already have an Okta account?
****
If you already have an Okta account, you can use it too. However, the Okta add-on makes things easier because it creates SPA and Web OIDC apps on Okta for you. It automatically configures their redirect URIs for Heroku too.

If you want to use an existing Okta account, I recommend using the https://cli.okta.com[Okta CLI]. The CLI makes it easy to create similar OIDC apps with `okta apps create`. You will need to make sure their redirect URIs match your Heroku app.
****

Update the `.okta.env` file in the `angular-deployment/notes-api` directory and copy the config vars into it, where `$OKTA_*` is the value from Heroku.

[source,shell]
----
export OKTA_OAUTH2_ISSUER=$OKTA_OAUTH2_ISSUER
export OKTA_OAUTH2_CLIENT_ID=$OKTA_OAUTH2_CLIENT_ID_WEB
export OKTA_OAUTH2_CLIENT_SECRET=$OKTA_OAUTH2_CLIENT_SECRET_WEB
----

[NOTE]
====
If you're on Windows without https://docs.microsoft.com/en-us/windows/wsl/install-win10[Windows Subsystem for Linux] installed, create an `okta.bat` file and use `SET` instead of `export`.
====

Start your Spring Boot app by navigating to the `notes-api` directory, sourcing this file, and running `./gradlew bootRun`.

[source,shell]
----
source .okta.env
./gradlew bootRun
----

[TIP]
.Environment Variables in IntelliJ IDEA
====
If you're using IntelliJ IDEA, you can copy the contents of `.okta.env` and paste its values as environment variables. Edit the **DemoApplication** configuration and click on the **Browse** icon on the right-side of **Environment variables**.

[[idea-edit-configuration]]
.Edit DemoApplication Configuration
image::../images/angular-deployment/idea-edit-configuration.png[Edit DemoApplication Configuration, 800, scaledwidth="100%"]

Next, click the paste icon. You'll need to delete `export` in the Name column. Now you can run your Spring Boot app with Okta from IDEA!

[[idea-env-variables]]
.IntelliJ Environment Variables
image::../images/angular-deployment/idea-env-variables.png[IntelliJ Environment Variables, 600, scaledwidth="100%"]
====

Next, configure Angular for OIDC authentication by modifying its `auth-routing.module.ts` to use the generated issuer, client ID, and update the callback URL.

[source,typescript]
.notes/src/app/auth-routing.module.ts
----
const oktaConfig = {
  issuer: '$OKTA_OAUTH2_ISSUER',
  redirectUri: '/callback',
  clientId: '$OKTA_OAUTH2_CLIENT_ID_SPA',
  scopes: ['openid', 'profile']
};
----

Install your Angular app's dependencies if you haven't already and start the application.

[source,shell]
----
npm i
ng serve
----

Open `http://localhost:4200` in your browser.

[[angular-home]]
.Angular Home
image::../images/angular-deployment/angular-home.png[Angular Home, 800, scaledwidth="100%"]

Click the **Login** button in the top right corner. You should be logged in straight away since you're already logged in to Okta. If you want to see the full authentication flow, log out, or try it in a private window. You can use the `$OKTA_ADMIN_EMAIL` and `$OKTA_ADMIN_PASSWORD` from your Heroku config variables for credentials. Create a note to make sure everything works.

[[first-note-recap]]
.First note
image::../images/angular-deployment/first-note.png[First note, 800, scaledwidth="100%"]

=== Prepare Angular + Spring Boot for Production

There are a couple of things you should do to make your app ready for production.

1. Make sure you're using the latest releases
2. Configure production URLs
3. Use PostgreSQL for the production database

You're going to want to continue to develop locally—so you'll want a production mode as well as a development mode.

=== Update Spring Boot and Angular Dependencies

I'm the type of developer that likes to use the latest releases of open-source libraries. I do this to take advantage of new features, performance optimizations, and security fixes.

There's a https://github.com/patrikerdes/gradle-use-latest-versions-plugin[Gradle Use Latest Versions Plugin] that provides a task to update dependencies to the latest version. Configure it by adding the following to the `plugins` block at the top of `notes-api/build.gradle.kts`.

[source,kotlin]
----
plugins {
    ...
    id("se.patrikerdes.use-latest-versions") version "0.2.18"
    id("com.github.ben-manes.versions") version "0.39.0"
}
----

Then run the following command in the `notes-api` directory to update your dependencies to the latest released versions.

[source,shell]
----
./gradlew useLatestVersions
----

You can verify everything still works by running `./gradlew bootRun` and navigating to `http://localhost:8080/api/notes`. You should be redirected to Okta to log in, then back to your app.

TIP: If your app fails to start, you need to run `source .okta.env` first.

For the Angular client, you can use https://www.npmjs.com/package/npm-check-updates[npm-check-updates] to upgrade npm dependencies.

[source,shell]
----
npm i -g npm-check-updates
ncu -u
----

At the time of this writing, this will upgrade Angular from version ~12.2.0 to ~12.2.12 and TypeScript to version ~4.4.4. Angular 12 supports TypeScript versions >=4.2.3 and <4.4, so you'll need to change `package.json` to specify TypeScript version `~4.3.5`.

[source,json]
----
"typescript": "~4.3.5"
----

While you're in there, change RxJS back to its original `~6.6.0` version.

[source,json]
----
"rxjs": "~6.6.0"
----

TIP: You can also use `npm update`, which is https://docs.npmjs.com/cli/v6/commands/npm-update[included in npm since v5].

Then run the following commands in the `notes` directory:

[source,shell]
----
npm i
npm audit fix
ng serve
----

Confirm you can still log in at `http://localhost:4200`.

=== Configure Production URLs

There are a few places where `localhost` is hard-coded:

1. `notes-api/src/main/kotlin/.../DemoApplication.kt` has `\http://localhost:4200`
2. `notes/src/app/shared/okta/auth-interceptor.ts` has `\http://localhost`
3. `notes/src/app/note/note.service.ts` has `\http://localhost:8080`

You need to change Spring Boot's code so other origins can make CORS requests too. Angular's code needs updating so access tokens will be sent to production URLs while API requests are sent to the correct endpoint.

Open the root directory in your favorite IDE and configure it so it loads `notes-api` as a Gradle project. Open `DemoApplication.kt` and change the `simpleCorsFilter` bean so it configures the allowed origins from your Spring environment.

[source,kotlin]
.notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
----
import org.springframework.beans.factory.annotation.Value

@SpringBootApplication
class DemoApplication {

    @Value("#{ @environment['allowed.origins'] ?: {} }")
    private lateinit var allowedOrigins: List<String>

    @Bean
    fun simpleCorsFilter(): FilterRegistrationBean<CorsFilter> {
        val source = UrlBasedCorsConfigurationSource()
        val config = CorsConfiguration()
        config.allowCredentials = true
        config.allowedOrigins = allowedOrigins
        config.allowedMethods = listOf("*");
        config.allowedHeaders = listOf("*")
        source.registerCorsConfiguration("/**", config)
        val bean = FilterRegistrationBean(CorsFilter(source))
        bean.order = Ordered.HIGHEST_PRECEDENCE
        return bean
    }
}
----

Define the `allowed.origins` property in `notes-api/src/main/resources/application.properties`.

[source,properties]
----
allowed.origins=http://localhost:4200
----

Angular has an https://angular.io/guide/build[environment concept] built-in. When you run `ng build` to create a production build, it replaces `environment.ts` with `environment.prod.ts`.

Open `environment.ts` and add an `apiUrl` variable for development. This file will be used when running `ng serve`.

[source,typescript]
.notes/src/environments/environment.ts
----
export const environment = {
  production: false,
  apiUrl: 'http://localhost:8080'
};
----

Edit `environment.prod.ts` to point to your production Heroku URL. Be sure to replace `bootiful-angular` with your app's name.

[source,typescript]
.notes/src/environments/environment.prod.ts
----
export const environment = {
  production: true,
  apiUrl: 'https://bootiful-angular.herokuapp.com'
};
----

Update `auth-interceptor.ts` to use `environment.apiUrl`.

[source%autofit,typescript]
.notes/src/app/shared/okta/auth.interceptor.ts
----
import { environment } from '../../../environments/environment';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {

  ...

  private async handleAccess(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const allowedOrigins = [environment.apiUrl];
    ...
  }
}
----

Update `notes.service.ts` as well.

[source,typescript]
.notes/src/app/note/note.service.ts
----
import { environment } from '../../environments/environment';
...

export class NoteService {
  ...
  api = `${environment.apiUrl}/api/notes`;
  ...

  find(filter: NoteFilter): Observable<Note[]> {
    ...

    const userNotes = `${environment.apiUrl}/user/notes`;
    ...
  }
}
----

=== Use PostgreSQL for the Production Database

H2 is a SQL database that works nicely for development. In production, you're going to want something a little more robust. Personally, I like PostgreSQL so I'll use it in this example.

Similar to Angular's environments, Spring and Maven have profiles that allow you to enable different behavior for different environments.

Open `notes-api/build.gradle.kts` and change the H2 dependency so PostgreSQL is used when `-Pprod` is passed in.

[source,kotlin]
----
if (project.hasProperty("prod")) {
    runtimeOnly("org.postgresql:postgresql")
} else {
    runtimeOnly("com.h2database:h2")
}
----

At the bottom of the file, add the following code to make the `prod` profile the default when `-Pprod` is included in Gradle commands.

[source,kotlin]
----
val profile = if (project.hasProperty("prod")) "prod" else "dev"

tasks.bootRun {
    args("--spring.profiles.active=${profile}")
}

tasks.processResources {
    rename("application-${profile}.properties", "application.properties")
}
----

Rename `notes-api/src/main/resources/application.properties` to `application-dev.properties` and add a URL for H2 so it will persist to disk, which retains data through restarts.

[source,properties]
----
allowed.origins=http://localhost:4200
spring.datasource.url=jdbc:h2:file:./build/h2db/notes;DB_CLOSE_DELAY=-1
spring.jpa.hibernate.ddl-auto=update
----

Create a `notes-api/src/main/docker/postgresql.yml` so you can test your `prod` profile settings.

[source,yaml]
----
version: '3.8'
services:
  notes-postgresql:
    image: postgres:14.0
    environment:
      - POSTGRES_USER=notes
      - POSTGRES_PASSWORD=@-xYcoZn2
    ports:
      - 5432:5432
----

Create an `application-prod.properties` file in the same directory as `application-dev.properties`. You'll override these properties with environment variables when you deploy to Heroku.

[source,properties]
.notes-api/src/main/resources/application-prod.properties
----
allowed.origins=http://localhost:4200
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:postgresql://localhost:5432/notes
spring.datasource.username=notes
spring.datasource.password=@-xYcoZn2
----

The word `user` is a keyword in PostgreSQL, so you'll need to change `user` to `username` in the `Note` entity.

[source,kotlin]
.notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
----
data class Note(@Id @GeneratedValue var id: Long? = null,
                var title: String? = null,
                var text: String? = null,
                @JsonIgnore var username: String? = null)
----

This will cause compilation errors and you'll need to rename method names and variables to fix them.

// todo: verify this looks OK in Print, PDF, and EPUB
.Click to see the diff
[%collapsible]
====
[source,diff]
----
diff --git a/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt b/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt
index 387e332..506d761 100644
--- a/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt
+++ b/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt
@@ -10,7 +10,7 @@ class DataInitializer(val repository: NotesRepository) : ApplicationRunner {
     @Throws(Exception::class)
     override fun run(args: ApplicationArguments) {
         for (x in 0..1000) {
-            repository.save(Note(title = "Note ${x}", user = "mraible@gmail.com"))
+            repository.save(Note(title = "Note ${x}", username = "mraible@gmail.com"))
         }
         repository.findAll().forEach { println(it) }
     }
diff --git a/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt b/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
index 6f1292c..22a5130 100644
--- a/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
+++ b/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
@@ -26,12 +26,12 @@ fun main(args: Array<String>) {
 data class Note(@Id @GeneratedValue var id: Long? = null,
                 var title: String? = null,
                 var text: String? = null,
-                @JsonIgnore var user: String? = null)
+                @JsonIgnore var username: String? = null)

 @RepositoryRestResource
 interface NotesRepository : JpaRepository<Note, Long> {
-    fun findAllByUser(name: String, pageable: Pageable): Page<Note>
-    fun findAllByUserAndTitleContainingIgnoreCase(name: String, title: String, pageable: Pageable): Page<Note>
+    fun findAllByUsername(name: String, pageable: Pageable): Page<Note>
+    fun findAllByUsernameAndTitleContainingIgnoreCase(name: String, title: String, pageable: Pageable): Page<Note>
 }

 @Component
@@ -42,6 +42,6 @@ class AddUserToNote {
     fun handleCreate(note: Note) {
         val username: String = SecurityContextHolder.getContext().getAuthentication().name
         println("Creating note: $note with user: $username")
-        note.user = username
+        note.username = username
     }
 }
diff --git a/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt b/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
index 0f71858..670fedd 100644
--- a/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
+++ b/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
@@ -15,10 +15,10 @@ class UserController(val repository: NotesRepository) {
     fun notes(principal: Principal, title: String?, pageable: Pageable): Page<Note> {
         println("Fetching notes for user: ${principal.name}")
         return if (title.isNullOrEmpty()) {
-            repository.findAllByUser(principal.name, pageable)
+            repository.findAllByUsername(principal.name, pageable)
         } else {
             println("Searching for title: ${title}")
-            repository.findAllByUserAndTitleContainingIgnoreCase(principal.name, title, pageable)
+            repository.findAllByUsernameAndTitleContainingIgnoreCase(principal.name, title, pageable)
         }
     }
----
====

You won't want to pre-populate your production database with a bunch of notes, so add a `@Profile` annotation to the top of `DataInitializer` so it only runs for the `dev` profile.

[source,kotlin]
----
import org.springframework.context.annotation.Profile
...

@Profile("dev")
class DataInitializer(val repository: NotesRepository) : ApplicationRunner {...}
----

To test your profiles, start PostgreSQL using Docker Compose.

[source,shell]
----
docker-compose -f src/main/docker/postgresql.yml up
----

CAUTION: If you have PostgreSQL installed and running locally, you'll need to stop the process for Docker Compose to work.

In another terminal, run your Spring Boot app.

[source,shell]
----
source .okta.env
./gradlew bootRun -Pprod
----

If it starts OK, confirm your Angular app can talk to it and get ready to deploy to production!

=== Deploy Spring Boot to Heroku

One of the easiest ways to interact with Heroku is with the Heroku CLI. https://devcenter.heroku.com/articles/heroku-cli[Install it] before proceeding with the instructions below.

[source,shell]
----
brew tap heroku/brew && brew install heroku
----

Open a terminal and log in to your Heroku account.

[source,shell]
----
heroku login
----

Heroku expects you to have one Git repo per application. However, in this particular example, there are multiple apps in the same repo. This is called a "`monorepo,`" where many projects are stored in the same repository.

Luckily, there's a https://elements.heroku.com/buildpacks/lstoll/heroku-buildpack-monorepo[heroku-buildpack-monorepo] that allows you to deploy multiple apps from the same repo.

You should already have a Heroku app that you added Okta to. Let's use it for hosting Spring Boot. Run `heroku apps` and you'll see the one you created.

[source,shell]
----
$ heroku apps
=== mraible@gmail.com Apps
bootiful-angular
----

You can run `heroku config -a $APP_NAME` to see your Okta variables. In my case, I'll be using `bootiful-angular` for `$APP_NAME`.

[source,shell]
----
APP_NAME=bootiful-angular
----

Associate your existing Git repo with the app on Heroku.

[source,shell]
----
heroku git:remote -a $APP_NAME
----

Set the `APP_BASE` config variable to point to the `notes-api` directory. While you're there, add the monorepo and Gradle buildpacks.

[source,shell]
----
heroku config:set APP_BASE=notes-api
heroku buildpacks:add https://github.com/lstoll/heroku-buildpack-monorepo
heroku buildpacks:add heroku/gradle
----

Attach a PostgreSQL database to your app.

[source,shell]
----
heroku addons:create heroku-postgresql
----

As part of this process, Heroku will create a `DATABASE_URL` configuration variable. It will also automatically detect Spring Boot and set variables for `SPRING_DATASOURCE_URL`, `SPRING_DATASOURCE_USERNAME`, AND `SPRING_DATASOURCE_PASSWORD`. These values will override what you have in `application-prod.properties`.

By default, https://devcenter.heroku.com/articles/deploying-gradle-apps-on-heroku[Heroku's Gradle support] runs `./gradlew build -x test`. Since you want it to run `./gradlew bootJar -Pprod`, you'll need to override it by setting a `GRADLE_TASK` config var.

[source,shell]
----
heroku config:set GRADLE_TASK="bootJar -Pprod"
----

The `$OKTA_*` environment variables don't have the same names as the Okta Spring Boot starter expects. This is because the Okta Heroku Add-On creates two apps: SPA and web. The web app's config variables end in `_WEB`. You'll have to make some changes so those variables are used for the Okta Spring Boot starter. One way to do so is to create a `Procfile` in the `notes-api` directory.

[source,shell]
----
web: java -Dserver.port=$PORT -Dokta.oauth2.client-id=${OKTA_OAUTH2_CLIENT_ID_WEB} -Dokta.oauth2.client-secret=${OKTA_OAUTH2_CLIENT_SECRET_WEB} -jar build/lib/*.jar
----

I think it's easier to rename the variable, so that's what I recommend. Run the following command and remove `_WEB` from the two variables that have it.

[source,shell]
----
heroku config:edit
----

Tell Heroku to use Java 11 by creating a `notes-api/system.properties` and specifying the Java runtime version:

[source,shell]
----
java.runtime.version=11
----

Now you're ready to deploy! Take a deep breath and witness how Heroku can deploy your Spring Boot + Kotlin app with a simple `git push`.

[source,shell]
----
git push heroku main
----

When I ran this command, I received this output:

[source,shell]
----
remote: Compressing source files... done.
remote: Building source:
remote:
remote: -----> Building on the Heroku-20 stack
remote: -----> Using buildpacks:
remote:        1. https://github.com/lstoll/heroku-buildpack-monorepo
remote:        2. heroku/gradle
remote: -----> Monorepo app detected
remote:       Copied notes-api to root of app successfully
remote: -----> Gradle app detected
remote: -----> Spring Boot detected
remote: -----> Installing JDK 11... done
remote: -----> Building Gradle app...
remote: -----> executing ./gradlew bootJar -Pprod
remote:        Downloading https://services.gradle.org/distributions/gradle-7.2-bin.zip
remote:        ........................................................................
remote:        > Task :compileKotlin
remote:        > Task :compileJava NO-SOURCE
remote:        > Task :processResources
remote:        > Task :classes
remote:        > Task :bootJarMainClassName
remote:        > Task :bootJar
remote:
remote:        BUILD SUCCESSFUL in 2m 12s
remote:        4 actionable tasks: 4 executed
remote: -----> Discovering process types
remote:        Procfile declares types     -> (none)
remote:        Default types for buildpack -> web
remote:
remote: -----> Compressing...
remote:        Done: 93.7M
remote: -----> Launching...
remote:        Released v9
remote:        https://bootiful-angular.herokuapp.com/ deployed to Heroku
remote:
remote: Verifying deploy... done.
To https://git.heroku.com/bootiful-angular.git
 * [new branch]      main -> main
Execution time: 3 min. 2 s.
----

Run `heroku open` to open your app. You'll be redirected to Okta to authenticate, then back to your app. It will display a 404 error message because you have nothing mapped to `/`. You can fix that by adding a `HomeController` with the following code:

[source,kotlin]
----
package com.okta.developer.notes

import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.core.oidc.user.OidcUser
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class HomeController {

    @GetMapping("/")
    fun hello(@AuthenticationPrincipal user: OidcUser): String {
        return "Hello, ${user.fullName}"
    }
}
----

Commit this change and run `git push heroku main` to update your app on Heroku.

Now when you access the app, it should say hello.

[[heroku-hello]]
.Hello, SUPER ADMIN
image::../images/angular-deployment/heroku-hello.png[Hello, SUPER ADMIN, 800, scaledwidth="100%"]

== Deploy Angular to Heroku with Secure Headers

An Angular app is composed of JavaScript, CSS, and HTML when built for production. It's extremely portable because it's just a set of static files. If you run `ng build`, the production-ready files will be created in `dist/<app-name>`. In this section, you'll learn how you can use your `package.json` scripts to hook into Heroku's lifecycle and how to deploy them with a simple `git push`.

You'll need to create another app on Heroku for the Angular frontend.

[source,shell]
----
heroku create
----

Set the `APP_BASE` config variable and add the necessary buildpacks to the app that was just created.

[source,shell]
----
APP_NAME=<app-name-from-heroku-create>
heroku config:set APP_BASE=notes -a $APP_NAME
heroku buildpacks:add https://github.com/lstoll/heroku-buildpack-monorepo -a $APP_NAME
heroku buildpacks:add heroku/nodejs -a $APP_NAME
----

Change `notes/package.json` to have a different `start` script.

[source,json]
----
"start": "http-server-spa dist/notes index.html $PORT",
----

Add a `heroku-postbuild` script to your `package.json`:

[source,json]
----
"heroku-postbuild": "ng build && npm install -g http-server-spa"
----

Commit your changes, add a new Git remote for this app, and deploy!

[source,shell]
----
git commit -am "Prepare for Heroku"
git remote add angular https://git.heroku.com/$APP_NAME.git
git push angular main
----

When it finishes deploying, you can open your Angular app with:

[source,shell]
----
heroku open --remote angular
----

NOTE: If you experience any issues, you can run `heroku logs --remote angular` to see your app's log files.

You won't be able to log in to your app until you modify its Sign-in redirect URI on Okta. Log in to your Okta dashboard. (tip: you can do this from the first Heroku app you created, under the **Resources** tab by clicking on **Okta**.) Go to the **Applications** section, find your **SPA** app, and edit it. Add `https://<angular-app-on-heroku>.herokuapp.com/callback` to the Sign-in redirect URIs and `https://<angular-app-on-heroku>.herokuapp.com` to the Sign-out redirect URIs.

You should be able to log in now, but you won't be able to add any notes. This is because you need to update the allowed origins in your Spring Boot app. Run the following command to add an `ALLOWED_ORIGINS` variable in your Spring Boot app.

[source,shell]
----
heroku config:set ALLOWED_ORIGINS=https://$APP_NAME.herokuapp.com --remote heroku
----

Now you should be able to add a note. Pat yourself on the back for a job well done!

One issue you'll experience is that you're going to lose your data between restarts. This is because Hibernate is configured to update your database schema each time. Change it to simply validate your schema by overriding the `ddl-auto` value in `application-prod.properties`.

[source,shell]
----
heroku config:set SPRING_JPA_HIBERNATE_DDL_AUTO=validate --remote heroku
----

=== Secure Angular Apps on Heroku

You've deployed your app to Heroku, but there are still a couple of security issues. The first is that if you access it using `http` (instead of `https`), it won't work. You'll get a blank page and an error from the Okta Angular SDK in your browser's console.

The second issue is that you'll score an **F** when you test it using https://securityheaders.com[securityheaders.com]. Heroku has a https://blog.heroku.com/using-http-headers-to-secure-your-site[blog post on using HTTP headers to secure your site] that will help you improve your score.

Create a `notes/static.json` file with the configuration for secure headers and redirect all HTTP requests to HTTPS.

[source,json]
.notes/static.json
----
{
  "headers": {
    "/**": {
      "Content-Security-Policy": "default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'; connect-src 'self' https://*.okta.com https://*.herokuapp.com",
      "Referrer-Policy": "no-referrer, strict-origin-when-cross-origin",
      "Strict-Transport-Security": "max-age=63072000; includeSubDomains",
      "X-Content-Type-Options": "nosniff",
      "X-Frame-Options": "DENY",
      "X-XSS-Protection": "1; mode=block",
      "Permissions-Policy": "geolocation=(self), microphone=(), accelerometer=(), camera=()"
    }
  },
  "https_only": true,
  "root": "dist/notes/",
  "routes": {
    "/**": "index.html"
  }
}
----

For `static.json` to be read, you have to use the https://github.com/heroku/heroku-buildpack-static[Heroku static buildpack]. This buildpack is made for SPA applications, so you can revert the `scripts` section of your `package.json` back to what you had previously.

[source,json]
.notes/package.json
----
"scripts": {
  "ng": "ng",
  "start": "ng serve",
  "build": "ng build",
  "watch": "ng build --watch --configuration development",
  "test": "ng test"
},
----

Commit your changes to Git, add the static buildpack, and redeploy your Angular app.

[source,shell]
----
git add .
git commit -am "Configure secure headers and static buildpack"
heroku buildpacks:add https://github.com/heroku/heroku-buildpack-static.git --remote angular
git push angular main
----

Now you'll have a security report you can be proud of!

[[heroku-headers]]
.Security Report Summary with an A
image::../images/angular-deployment/heroku-headers.png[Security Report Summary with an A, 800, scaledwidth="100%"]

== Use `ng deploy` with Firebase, Netlify, and AWS

In Angular CLI v8.3.0, an `ng deploy` command was introduced that allows you to automate deploying to many different cloud providers. I thought it'd be fun to try a few of these out and see if it's possible to optimize the headers to get the same **A** rating that you were able to get with Heroku.

Below are the https://angular.io/guide/deployment[current providers and packages] supported by this command.

|===
|Hosting provider |npm package

|Azure
|https://npmjs.org/package/@azure/ng-deploy[`@azure/ng-deploy`]

|AWS S3
|https://www.npmjs.com/package/@jefiozie/ngx-aws-deploy[`@jefiozie/ngx-aws-deploy`]

|Firebase
|https://npmjs.org/package/@angular/fire[`@angular/fire`]

|GitHub pages
|https://npmjs.org/package/angular-cli-ghpages[`angular-cli-ghpages`]

|Netlify
|https://www.npmjs.com/package/@netlify-builder/deploy[`@netlify-builder/deploy`]

|NPM
|https://npmjs.org/package/ngx-deploy-npm[`ngx-deploy-npm`]

|Vercel
|https://www.npmjs.com/package/@zeit/ng-deploy[`@zeit/ng-deploy`]

|===

In the following section, I'll show you how to deploy to a few that piqued my interest (Firebase, Netlify, and AWS S3).

=== Angular Deployment to Firebase

Create a `firebase` branch so you can make changes without affecting the work you've done for Heroku deployments.

[source,shell]
----
git checkout -b firebase
----

Open a browser and go to https://firebase.google.com/[firebase.google.com]. Log in to your account, go to the console, and create a new project.

Install the Firebase CLI and authenticate from your terminal:

[source,shell]
----
npm install -g firebase-tools
firebase login --reauth
----

Run `ng add @angular/fire` in the `notes` directory and your new project should show up in the list. When prompted for features to set up, select **ng deploy -- hosting**.

[source,shell]
----
? Please select a project: notes-1337
CREATE .firebaserc (194 bytes)
UPDATE .gitignore (658 bytes)
UPDATE angular.json (3363 bytes)
UPDATE firebase.json (783 bytes)
----

Now you can run `ng deploy` and everything should work.

You'll need to add the project's URL as an allowed origin in your Spring Boot app on Heroku. Copy the printed `Hosting URL` value and run the following command:

[source,shell]
----
heroku config:edit --remote heroku
----

Add the new URL after your existing Heroku one, separating them with a comma. For example:

[source,shell]
----
ALLOWED_ORIGINS='https://arcane-beach-51361.herokuapp.com,https://notes-1337-fe10c.web.app'
----

You'll also need to modify your Okta SPA app to add your Firebase URL as a Sign-in redirect URI and Sign-out redirect URI. For mine, I added:

* Sign-in redirect URI: `\https://notes-1337-fe10c.web.app/callback`
* Sign-out redirect URI: `\https://notes-1337-fe10c.web.app`

Open your Firebase URL in your browser, log in, and you should be able to see the note you added on Heroku.

=== Strong Security Headers on Firebase

If you test your new Firebase site on https://securityheaders.com/[securityheaders.com], you'll score a **D**. Luckily, you can https://firebase.google.com/docs/hosting/full-config#headers[configure headers] in your `firebase.json` file. Edit this file and modify the `headers` key like the following:

[source,json]
----
"headers": [
  {
    "source": "/**",
    "headers": [
      {
        "key": "Cache-Control",
        "value": "public,max-age=31536000,immutable"
      },
      {
        "key": "Content-Security-Policy",
        "value": "default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'; connect-src 'self' https://*.okta.com https://*.herokuapp.com"
      },
      {
        "key": "Referrer-Policy",
        "value": "no-referrer, strict-origin-when-cross-origin"
      },
      {
        "key": "X-Content-Type-Options",
        "value": "nosniff"
      },
      {
        "key": "X-Frame-Options",
        "value": "DENY"
      },
      {
        "key": "X-XSS-Protection",
        "value": "1; mode=block"
      },
      {
        "key": "Permissions-Policy",
        "value": "geolocation=(self), microphone=(), accelerometer=(), camera=()"
      }
    ]
  },
  {
    "source": "/@(ngsw-worker.js|ngsw.json)",
    "headers": [
      {
        "key": "Cache-Control",
        "value": "no-cache"
      }
    ]
  }
],
----

NOTE: You don't need to include a `Strict-Transport-Security` header because Firebase includes it by default.

Run `ng deploy` and you should get an **A** now!

[[firebase-headers]]
.Firebase app score from securityheaders.com
image::../images/angular-deployment/firebase-headers.png[Firebase app score from securityheaders.com, 800, scaledwidth="100%"]

Commit your changes to your `firebase` branch.

[source,shell]
----
git add .
git commit -am "Add Firebase deployment"
----

=== Angular Deployment to Netlify

Netlify is a hosting provider for static sites that I've enjoyed using in the past. They offer continuous integration, HTML forms, AWS Lambda functions, and CMS functionality. I wrote about Netlify in https://developer.okta.com/blog/2020/02/18/gatsby-react-netlify[Build a Secure Blog with Gatsby, React, and Netlify].

Check out your `main` branch and create a new `netlify` one.

[source,shell]
----
git checkout main
git checkout -b netlify
----

Before running the command to add Netlify support, you'll need to https://app.netlify.com/signup[create a Netlify account]. Once you're signed in, create a new site. Netlify makes it easy to connect a site via Git, but since I want to demonstrate `ng deploy`, you'll need to create a temporary directory with an `index.html` file in it. I put "`Hello, World`" in the HTML file, then dragged the directory into my browser window.

[[netlify-create-site]]
.Netlify create site
image::../images/angular-deployment/netlify-create-site.png[Netlify create site, 650, scaledwidth="100%"]

Click on your new site > **Site Settings** to copy your **API ID** to a text editor. You'll also need a personal access token. To create one, click on your avatar in the top right > **User settings** > **Applications** and click **New access token**. Copy the generated token to your text editor.

Run the command below to add Netlify deployment support.

[source,shell]
----
ng add @netlify-builder/deploy
----

Copy and paste your API ID and personal access token when prompted, then run `ng deploy` to deploy your site.

Update your Spring Boot app on Heroku to allow your Netlify app URL:

[source,shell]
----
heroku config:edit --remote heroku
----

Make sure to append the URL to your existing ones, separating them with a comma.

[source,shell]
----
ALLOWED_ORIGINS='...,https://keen-ramanujan-ca0c92.netlify.app'
----

You'll also need to update your Okta SPA app to allow the URL as a sign-in and sign-out redirect.

If you try to log in, you'll get a `Page Not Found` error stemming from Okta trying to redirect back to your app. This happens because Netlify doesn't know your app is a SPA that manages its own routes. To fix this, create a `_redirects` file in the `notes/src` directory with the following contents:

[source,shell]
----
/*    /index.html   200
----

TIP: You can learn more about https://docs.netlify.com/routing/redirects/rewrites-proxies/#history-pushstate-and-single-page-apps[configuring Netlify for SPAs in their documentation].

Then, modify `angular.json` to include this file in its assets.

[source,json]
----
"assets": [
  "src/_redirects",
  "src/favicon.ico",
  "src/assets"
],
----

Run `ng deploy` again and you should be able to log in successfully.

=== Better Security Headers on Netlify

If you test your new Firebase site on https://securityheaders.com/[securityheaders.com], you'll score a **D**. Netlify allows you to add https://docs.netlify.com/routing/headers/[custom headers] to improve your score.

Create a `src/_headers` file with the following contents. Note that the first line in this file is used to indicate "`all paths under `/``".

[source,text]
----
/*
  Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'; connect-src 'self' https://*.okta.com https://*.herokuapp.com
  Referrer-Policy: no-referrer, strict-origin-when-cross-origin
  X-Content-Type-Options: nosniff
  X-Frame-Options: DENY
  X-XSS-Protection: 1; mode=block
  Permissions-Policy: geolocation=(self), microphone=(), accelerometer=(), camera=()
----

NOTE: You don't need to include a `Strict-Transport-Security` header because Netlify includes one by default.

Modify `angular.json` to include this file in its assets.

[source,json]
----
"assets": [
  "src/_headers",
  "src/_redirects",
  "src/favicon.ico",
  "src/assets"
],
----

Run `ng deploy` and you should get an **A** now!

[[netlify-headers]]
.Netlify score from securityheaders.com
image::../images/angular-deployment/netlify-headers.png[Netlify score from securityheaders.com, 800, scaledwidth="100%"]

Commit your changes to the `netlify` branch.

[source,shell]
----
git add .
git commit -am "Add Netlify deployment"
----

[WARNING]
====
The Netlify schematic writes your access token to `angular.json`, which is a security risk (if you push these changes to your source control system).

[source,json]
----
"deploy": {
  "builder": "@netlify-builder/deploy:deploy",
  "options": {
    "outputPath": "dist/notes",
    "netlifyToken": "04b966f772XXX...",
    "siteId": "1dda959c-XXXX..."
  }
}
----

I was notified of this issue by https://gitguardian.com/[GitGuardian], which I use to monitor my repos. If you check in this change, make sure to delete the access token on Netlify.
====

=== Angular Deployment to AWS S3

Amazon Simple Storage Service (Amazon S3) is an object storage service that is a popular option for hosting static sites.

Check out your `main` branch and create a new `aws` one.

[source,shell]
----
git checkout main
git checkout -b aws
----

Before running the command to add S3 deployment support, you'll need a few things:

* An S3 Bucket
* An AWS Region Name
* A Secret Access Key
* An Access Key ID

You'll also need to https://portal.aws.amazon.com/billing/signup[create an AWS account]. After creating an account, go to the https://s3.console.aws.amazon.com/[Amazon S3 console]. Click **Create Bucket** and give it a name you'll remember. Use the default region selected for you and click **Create Bucket**.

To create the secret access key, go to your https://console.aws.amazon.com/iam/home?nc2=h_m_sc#/security_credentials[security credentials page]. Expand the **Access keys** section, and then **Create New Access Key**. Click **Show Access Key** and copy the values into a text editor.

TIP: If you have trouble creating a secret access key, see https://aws.amazon.com/blogs/security/how-to-find-update-access-keys-password-mfa-aws-management-console/[this blog post].

Add the `@jefiozie/ngx-aws-deploy` package to deploy to S3:

[source,shell]
----
ng add @jefiozie/ngx-aws-deploy
----

You won't be prompted for your AWS settings because of the authors have realized it's not a good idea to add secrets to `angular.json`.

Run `ng deploy` with your AWS setting to deploy your Angular app to your AWS S3 bucket.

[source,shell]
----
NG_DEPLOY_AWS_ACCESS_KEY_ID=<KEY_ID> NG_DEPLOY_AWS_SECRET_ACCESS_KEY=<KEY> \
  NG_DEPLOY_AWS_BUCKET=<BUCKET_NAME> NG_DEPLOY_AWS_REGION=<REGION> ng deploy
----

Next, you need to https://docs.aws.amazon.com/AmazonS3/latest/user-guide/static-website-hosting.html[configure S3 for static website hosting]. Go to your bucket > **Properties** > **Static website hosting** > **Edit**.

Type `index.html` for the index and error document and click **Save changes**.

[[aws-static-website]]
.AWS static website
image::../images/angular-deployment/aws-static-website.png[AWS static website, 684, scaledwidth="100%"]

By default, Amazon S3 blocks public access to your buckets. Go to the **Permissions** tab. Click the **Edit** button, clear **Block all public access**, and click **Save changes**.

The last step you need to do to make it public is add a bucket policy. Go to **Permissions** > **Bucket Policy** and paste the following into the editor, replacing `{your-bucket-name}` with your bucket's name.

[source,json]
----
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "PublicReadGetObject",
            "Effect": "Allow",
            "Principal": "*",
            "Action": [
                "s3:GetObject"
            ],
            "Resource": [
                "arn:aws:s3:::{your-bucket-name}/*"
            ]
        }
    ]
}
----

Click **Save changes** to continue.

At this point, you could navigate to `\https://<bucket-name>.s3-website-<region-name>.amazonaws.com` in your browser, and the application will load. However, there's no HTTP to HTTPS redirect by default. You can https://aws.amazon.com/premiumsupport/knowledge-center/cloudfront-https-requests-s3/[use CloudFront to solve these issues].

Open the https://console.aws.amazon.com/cloudfront/[CloudFront console] and choose **Create Distribution**. Click in the **Origin Domain Name** field and select your S3 bucket.

Set the **Viewer Protocol Policy** to `Redirect HTTP to HTTPS` and allow all HTTP methods. Under the **Response headers policy**, click **Create Policy**. Name it something you'll remember and enable all the security headers.

Set the values to the defaults unless specified below:

* X-Frame-Options: `DENY`
* X-XSS-Protection: `Enabled` and select `block`
* Referrer-Policy: `strict-origin-when-cross-origin`
* Content-Security-Policy: `default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'; connect-src 'self' https://*.okta.com https://*.herokuapp.com`

Add a Custom header for `Permissions-Policy`:

* Permissions-Policy: `geolocation=(self), microphone=(), accelerometer=(), camera=()`

Select **Origin override** if it's not selected for any headers by default. Click **Create**.

Back on your distribution page, refresh the **Response headers policy** options and select the policy you just created.

Near the bottom, enter `index.html` as the **Default Root Object**, and select **Create Distribution**. When the Last modified column changes from `Deploying` to today's date, navigate to the domain in your browser.

NOTE: Once you've created your distribution, it can take 20 minutes for it to deploy.

After your distribution is deployed, update your Spring Boot app on Heroku to allow your CloudFront URL:

[source,shell]
----
heroku config:edit --remote heroku
----

Make sure to append the URL to your existing ones, separating them with a comma.

[source,shell]
----
ALLOWED_ORIGINS='...,https://d1xnzbdvvkfkyn.cloudfront.net'
----

Update your Okta SPA app to whitelist the URL as a redirect, too.

If you try to log in, you'll get a 403 when redirecting back to the site. To fix this, edit your distribution > **Error pages**. Create two custom error responses for `404` and `403`. Return a path of `/index.html` and a `200: OK` response code.

Now you should be able to authenticate to your Angular app on AWS successfully!

=== Awesome Security Headers with AWS CloudFront + S3

If you test your new CloudFront + S3 site on https://securityheaders.com/[securityheaders.com], you'll get an **A**.

[[aws-headers]]
.AWS score from securityheaders.com
image::../images/angular-deployment/aws-headers.png[AWS score from securityheaders.com, 800, scaledwidth="100%"]

Commit your changes to the `aws` branch.

[source,shell]
----
git commit -am "Add AWS S3 deployment"
----

== Summary

In this section, you learned how to upgrade Angular and Spring Boot to their latest versions and make them production-ready. You used the https://devcenter.heroku.com/articles/okta[Okta add-on for Heroku] to add OAuth 2.0 + OIDC to both apps, then deployed them to Heroku. After you got them working on Heroku with PostgreSQL, you learned how to deploy the Angular app to Firebase, Netlify, and AWS.

You learned how to make your Angular app more secure with security headers, force HTTPS, and make each cloud provider SPA-aware.

TIP: You can download the code for this book's examples from InfoQ. The `angular-deployment` directory has this chapter's completed example.

In the next section, I'll show you how to containerize and deploy your Angular + Spring Boot app with Docker. You'll learn how to combine them into a JAR and use server-side authorization code flow (the most secure OAuth 2.0 flow). As icing on the cake, I'll show you how to deploy to Heroku and Knative on Google Cloud!
