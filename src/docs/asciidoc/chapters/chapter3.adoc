[[chapter-3]]
= Chapter 3

3. Angular Deployment
- Deploy Angular to Heroku with Secure Headers
- Use `ng deploy` with Firebase, Netlify, and AWS
- Dockerize an Angular App
- Combine Angular and Spring Boot in a Single Artifact
- Build a Docker Image with Jib
- Run via Docker on Heroku, Cloud Foundry, and KNative


One of the more popular combinations of frontend and backend frameworks is Angular + Spring Boot. I've written several tutorials about how to combine the two—from keeping them as separate apps to combining them into a single artifact. But, what about deployment?

Developers ask me from time-to-time, "What's the best way to do Angular  deployment?" In this tutorial, I'll show you several options. I'll start by showing you how to deploy a Spring Boot app to Heroku. Then, I'll show how to deploy a separate Angular app to Heroku.

There are lots of tutorials and information in the Java community on how to deploy Spring Boot apps, so I'll leave the Spring Boot API on Heroku and show other Angular deployment options, including Firebase, Netlify, and AWS S3.

image::{% asset_path 'blog/angular-deployment/angular-deployment.png' %}[alt=Angular Deployment with a Side of Spring Boot,width=800,align=center]

toc::[]

You can also https://youtu.be/Hx9SbQ1ANLk[watch this tutorial as a screencast]. 👇

++++
<div style="text-align: center; margin-bottom: 1.25rem">
<iframe width="700" height="394" style="max-width: 100%" src="https://www.youtube.com/embed/Hx9SbQ1ANLk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
++++

== Create an Angular + Spring Boot App

Since this tutorial is more about deployment than app creation, you can start with an existing Angular + Spring Boot app that I created previously. It's a note-taking app that uses Kotlin and Spring Boot 2.2 on the backend and Angular 9 on the frontend. It's secured with OpenID Connect (OIDC). If you'd like to see how I built it, you can read the following tutorials:

* link:/blog/2020/01/06/crud-angular-9-spring-boot-2[Build a CRUD App with Angular 9 and Spring Boot 2.2]
* link:/blog/2020/03/02/angular-bootstrap[Build Beautiful Angular Apps with Bootstrap]

One of the slick features of this app is its full-featured data table that allows sorting, searching, and pagination. This feature is powered by NG Bootstrap and Spring Data JPA. Below is a screenshot:

image::{% asset_path 'blog/angular-deployment/notes-list-with-sorting.png' %}[alt=Notes list with sorting,width=800,align=center]

Clone the application into an `okta-angular-deployment-example` directory.

[source,shell]
----
git clone https://github.com/oktadeveloper/okta-angular-bootstrap-example.git \
 okta-angular-deployment-example
----

**Prerequisites:**

* https://adoptopenjdk.net/[Java 11]+
* https://nodejs.org/[Node 12]+
* https://docs.docker.com/get-docker/[Docker]
* An https://developer.okta.com/signup/[Okta Developer Account]

=== Secure Your Angular + Spring Boot App with OIDC

To begin, you'll need to https://signup.heroku.com/login[create a Heroku account]. If you already have a Heroku account, https://id.heroku.com/login[log in to it]. Once you're logged in, create a new app. I named mine `bootiful-angular`.

image::{% asset_path 'blog/angular-deployment/heroku-create-app.png' %}[alt=Create Heroku app,width=700,align=center]

After creating your app, click on the **Resources** tab and add the **Okta** add-on.

image::{% asset_path 'blog/angular-deployment/okta-add-on.png' %}[alt=Okta Add-On,width=475,align=center]

CAUTION: If you haven't entered a credit card for your Heroku account, you will receive an error. This is because Heroku requires you to have a credit card on file to use any of their add-ons, even for free ones. This is part of Heroku's assurance to guard against misuse (real person, real credit card, etc.). I think this is a good security practice. Simply add a credit card to continue.

Click **Provision** and wait 20-30 seconds while your Okta account is created and OIDC apps are registered. Now go to your app's **Settings** tab and click the **Reveal Config Vars** button. The Config Vars displayed are the environment variables you can use to configure both Angular and Spring Boot for OIDC authentication.

image::{% asset_path 'blog/angular-deployment/heroku-config-vars.png' %}[alt=Okta Add-On,width=800,align=center]

Create an `okta.env` file in the `okta-angular-deployment-example/notes-api` directory and copy the config vars into it, where `$OKTA_*` is the value from Heroku.

[source,shell]
----
export OKTA_OAUTH2_ISSUER=$OKTA_OAUTH2_ISSUER
export OKTA_OAUTH2_CLIENT_ID=$OKTA_OAUTH2_CLIENT_ID_WEB
export OKTA_OAUTH2_CLIENT_SECRET=$OKTA_OAUTH2_CLIENT_SECRET_WEB
----

[NOTE]
====
If you're on Windows without https://docs.microsoft.com/en-us/windows/wsl/install-win10[Windows Subsystem for Linux] installed, create an `okta.bat` file and use `SET` instead of `export`.
====

Start your Spring Boot app by navigating to the `notes-api` directory, sourcing this file, and running `./gradlew bootRun`.

[source,shell]
----
source okta.env
./gradlew bootRun
----

[TIP]
.Environment Variables in IntelliJ IDEA
====
If you're using IntelliJ IDEA, you can copy the contents of `okta.env` and paste its values as environment variables. Edit the **DemoApplication** configuration and click on the **Browse** icon on the right-side of **Environment variables**.

image::{% asset_path 'blog/angular-deployment/idea-edit-configuration.png' %}[alt=Edit DemoApplication Configuration,width=800,align=center]

Next, click the paste icon. You'll need to delete `export` in the Name column. Now you can run your Spring Boot app with Okta from IDEA!

image::{% asset_path 'blog/angular-deployment/idea-env-variables.png' %}[alt=IntelliJ Environment Variables,width=600,align=center]
====

Next, configure Angular for OIDC authentication by modifying its `auth-routing.module.ts` to use the generated issuer, client ID, and update the callback URL.

[source,typescript]
.notes/src/app/auth-routing.module.ts
----
const oktaConfig = {
  issuer: '$OKTA_OAUTH2_ISSUER',
  redirectUri: window.location.origin + '/callback',
  clientId: '$OKTA_OAUTH2_CLIENT_ID_SPA',
  pkce: true
};

const routes: Routes = [
  ...
  {
    path: '/callback',
    component: OktaCallbackComponent
  }
];
----

Install your Angular app's dependencies and start it.

[source,shell]
----
npm i
ng serve
----

Open `http://localhost:4200` in your browser.

image::{% asset_path 'blog/angular-deployment/angular-home.png' %}[alt=Angular Home,width=800,align=center]

Click the **Login** button in the top right corner. You should be logged in straight-away, since you're already logged in to Okta. If you want to see the full authentication flow, log out, or try it in a private window. You can use the `$OKTA_ADMIN_EMAIL` and `$OKTA_ADMIN_PASSWORD` from your Heroku config variables for credentials. Create a note to make sure everything works.

image::{% asset_path 'blog/angular-deployment/first-note.png' %}[alt=First note,width=800,align=center]

Commit your progress to Git from the top-level `okta-angular-deployment-example` directory.

[source,shell]
----
git commit -am "Add Okta OIDC Configuration"
----

== Prepare Angular + Spring Boot for Production

There are a couple of things you should do to make your app ready for production.

1. Make sure you're using the latest releases
2. Configure production URLs
3. Use PostgreSQL for the production database

You're going to want to continue to develop locally—so you'll want a production mode as well as a development mode.

=== Update Spring Boot and Angular Dependencies

I'm the type of developer that likes to use the latest releases of open source libraries. I do this to take advantage of new features, performance optimizations, and security fixes.

There's a https://github.com/patrikerdes/gradle-use-latest-versions-plugin[Gradle Use Latest Versions Plugin] that provides a task to update dependencies to the latest version. Configure it by adding the following to the `plugins` block at the top of `notes-api/build.gradle.kts`.

[source,kotlin]
----
plugins {
    id("se.patrikerdes.use-latest-versions") version "0.2.13"
    id("com.github.ben-manes.versions") version "0.28.0"
    ...
}
----

For compatibility with Spring Boot 2.3, you'll need to update the Gradle Wrapper to use Gradle 6.3+.

[source,shell]
----
./gradlew wrapper --gradle-version=6.5 --distribution-type=bin
----

Then run the following command in the `notes-api` directory to update your dependencies to the latest released versions.

[source,shell]
----
./gradlew useLatestVersions
----

You can verify everything still works by running `./gradlew bootRun` and navigating to `http://localhost:8080/api/notes`. You should be redirected to Okta to log in, then back to your app.

TIP: If your app fails to start, you need to run `source okta.env` first.

For the Angular client, you can use https://www.npmjs.com/package/npm-check-updates[npm-check-updates] to upgrade npm dependencies.

[source,shell]
----
npm i -g npm-check-updates
ncu -u
----

At the time of this writing, this will upgrade Angular to version 9.1.9 and TypeScript to version 3.9.3. Angular 9 supports TypeScript versions >=3.6.4 and <3.9.0, so you'll need to change `package.json` to specify TypeScript 3.8.3.

[source,json]
----
"typescript": "~3.8.3"
----

Then run the following commands in the `notes` directory:

[source,shell]
----
npm i
npm audit fix
ng serve
----

Confirm you can still log in at `http://localhost:4200`.

Commit all your changes to source control.

[source,shell]
----
git commit -am "Update dependencies to latest versions"
----

=== Configure Production URLs

There are a few places where `localhost` is hard-coded:

1. `notes-api/src/main/kotlin/.../DemoApplication.kt` has `\http://localhost:4200`
2. `notes/src/app/shared/okta/auth-interceptor.ts` has `\http://localhost`
3. `notes/src/app/note/note.service.ts` has `\http://localhost:8080`

You need to change Spring Boot's code so other origins can make CORS requests too. Angular's code needs updating so access tokens will be sent to production URLs while API requests are sent to the correct endpoint.

Open the root directory in your favorite IDE and configure it so it loads `notes-api` as a Gradle project. Open `DemoApplication.kt` and change the `simpleCorsFilter` bean so it configures the allowed origins from your Spring environment.

[source,kotlin]
.notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
----
import org.springframework.beans.factory.annotation.Value

@SpringBootApplication
class DemoApplication {

    @Value("#{ @environment['allowed.origins'] ?: {} }")
    private lateinit var allowedOrigins: List<String>

    @Bean
    fun simpleCorsFilter(): FilterRegistrationBean<CorsFilter> {
        val source = UrlBasedCorsConfigurationSource()
        val config = CorsConfiguration()
        config.allowCredentials = true
        config.allowedOrigins = allowedOrigins
        config.allowedMethods = listOf("*");
        config.allowedHeaders = listOf("*")
        source.registerCorsConfiguration("/**", config)
        val bean = FilterRegistrationBean(CorsFilter(source))
        bean.order = Ordered.HIGHEST_PRECEDENCE
        return bean
    }
}
----

Define the `allowed.origins` property in `notes-api/src/main/resources/application.properties`.

[source,properties]
----
allowed.origins=http://localhost:4200
----

Angular has an https://angular.io/guide/build[environment concept] built-in. When you run `ng build --prod` to create a production build, it replaces `environment.ts` with `environment.prod.ts`.

Open `environment.ts` and add an `apiUrl` variable for development.

[source,typescript]
.notes/src/environments/environment.ts
----
export const environment = {
  production: false,
  apiUrl: 'http://localhost:8080'
};
----

Edit `environment.prod.ts` to point to your production Heroku URL. Be sure to replace `bootiful-angular` with your app's name.

[source,typescript]
.notes/src/environments/environment.prod.ts
----
export const environment = {
  production: false,
  apiUrl: 'https://bootiful-angular.herokuapp.com'
};
----

Update `auth-interceptor.ts` to use `environment.apiUrl`.

[source,typescript]
.notes/src/app/shared/okta/auth.interceptor.ts
----
import { environment } from '../../../environments/environment';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {

  ...

  private async handleAccess(request: HttpRequest<any>, next: HttpHandler): Promise<HttpEvent<any>> {
    const allowedOrigins = [environment.apiUrl];
    ...
  }
}
----

Update `notes.service.ts` as well.

[source,typescript]
.notes/src/app/note/note.service.ts
----
import { environment } from '../../environments/environment';
...

export class NoteService {
  ...
  api = `${environment.apiUrl}/api/notes`;
  ...

  find(filter: NoteFilter): Observable<Note[]> {
    ...

    const userNotes = `${environment.apiUrl}/user/notes`;
    ...
  }
}
----

=== Use PostgreSQL for the Production Database

H2 is a SQL database that works nicely for development. In production, you're going to want something a little more robust. Personally, I like PostgreSQL so I'll use it in this example.

Similar to Angular's environments, Spring and Maven have profiles that allow you to enable different behavior for different environments.

Open `notes-api/build.gradle.kts` and change the H2 dependency so PostgreSQL is used when `-Pprod` is passed in.

[source,kotlin]
----
if (project.hasProperty("prod")) {
    runtimeOnly("org.postgresql:postgresql")
} else {
    runtimeOnly("com.h2database:h2")
}
----

At the bottom of the file, add the following code to make the `prod` profile the default when `-Pprod` is included in Gradle commands.

[source,kotlin]
----
val profile = if (project.hasProperty("prod")) "prod" else "dev"

tasks.bootRun {
    args("--spring.profiles.active=${profile}")
}

tasks.processResources {
    rename("application-${profile}.properties", "application.properties")
}
----

Rename `notes-api/src/main/resources/application.properties` to `application-dev.properties` and add a URL for H2 so it will persist to disk, which retains data through restarts.

[source,properties]
----
allowed.origins=http://localhost:4200
spring.datasource.url=jdbc:h2:file:./build/h2db/notes;DB_CLOSE_DELAY=-1
----

Create a `notes-api/src/main/docker/postgresql.yml` so you can test your `prod` profile settings.

[source,yaml]
----
version: '2'
services:
  notes-postgresql:
    image: postgres:12.1
    environment:
      - POSTGRES_USER=notes
      - POSTGRES_PASSWORD=
    ports:
      - 5432:5432
----

Create an `application-prod.properties` file in the same directory as `application-dev.properties`. You'll override these properties with environment variables when you deploy to Heroku.

[source,properties]
.notes-api/src/main/resources/application-prod.properties
----
allowed.origins=http://localhost:4200
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:postgresql://localhost:5432/notes
spring.datasource.username=notes
spring.datasource.password=
----

The word `user` is a keyword in PostgreSQL, so you'll need to change `user` to `username` in the `Note` entity.

[source,kotlin]
.notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
----
data class Note(@Id @GeneratedValue var id: Long? = null,
                var title: String? = null,
                var text: String? = null,
                @JsonIgnore var username: String? = null)
----

This will cause compilation errors and you'll need to rename method names and variables to fix them.

.Click to see the diff
[%collapsible]
====
[source,diff]
----
diff --git a/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt b/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt
index 387e332..506d761 100644
--- a/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt
+++ b/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt
@@ -10,7 +10,7 @@ class DataInitializer(val repository: NotesRepository) : ApplicationRunner {
     @Throws(Exception::class)
     override fun run(args: ApplicationArguments) {
         for (x in 0..1000) {
-            repository.save(Note(title = "Note ${x}", user = "matt.raible@okta.com"))
+            repository.save(Note(title = "Note ${x}", username = "matt.raible@okta.com"))
         }
         repository.findAll().forEach { println(it) }
     }
diff --git a/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt b/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
index 6f1292c..22a5130 100644
--- a/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
+++ b/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
@@ -26,12 +26,12 @@ fun main(args: Array<String>) {
 data class Note(@Id @GeneratedValue var id: Long? = null,
                 var title: String? = null,
                 var text: String? = null,
-                @JsonIgnore var user: String? = null)
+                @JsonIgnore var username: String? = null)

 @RepositoryRestResource
 interface NotesRepository : JpaRepository<Note, Long> {
-    fun findAllByUser(name: String, pageable: Pageable): Page<Note>
-    fun findAllByUserAndTitleContainingIgnoreCase(name: String, title: String, pageable: Pageable): Page<Note>
+    fun findAllByUsername(name: String, pageable: Pageable): Page<Note>
+    fun findAllByUsernameAndTitleContainingIgnoreCase(name: String, title: String, pageable: Pageable): Page<Note>
 }

 @Component
@@ -42,6 +42,6 @@ class AddUserToNote {
     fun handleCreate(note: Note) {
         val username: String = SecurityContextHolder.getContext().getAuthentication().name
         println("Creating note: $note with user: $username")
-        note.user = username
+        note.username = username
     }
 }
diff --git a/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt b/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
index 0f71858..670fedd 100644
--- a/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
+++ b/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
@@ -15,10 +15,10 @@ class UserController(val repository: NotesRepository) {
     fun notes(principal: Principal, title: String?, pageable: Pageable): Page<Note> {
         println("Fetching notes for user: ${principal.name}")
         return if (title.isNullOrEmpty()) {
-            repository.findAllByUser(principal.name, pageable)
+            repository.findAllByUsername(principal.name, pageable)
         } else {
             println("Searching for title: ${title}")
-            repository.findAllByUserAndTitleContainingIgnoreCase(principal.name, title, pageable)
+            repository.findAllByUsernameAndTitleContainingIgnoreCase(principal.name, title, pageable)
         }
     }
----
====

You won't want to pre-populate your production database with a bunch of notes, so add a `@Profile` annotation to the top of `DataInitializer` so it only runs for the `dev` profile.

[source,kotlin]
----
import org.springframework.context.annotation.Profile
...

@Profile("dev")
class DataInitializer(val repository: NotesRepository) : ApplicationRunner {...}
----

To test your profiles, start PostgreSQL using Docker Compose.

[source,shell]
----
docker-compose -f src/main/docker/postgresql.yml up
----

CAUTION: If you have PostreSQL installed and running locally, you'll need to stop the process for Docker Compose to work.

In another terminal, run your Spring Boot app.

[source,shell]
----
source okta.env
./gradlew bootRun -Pprod
----

If it starts OK, confirm your Angular app can talk to it and get ready to deploy to production!

[source,shell]
----
git commit -am "Configure environments for production"
----

== Deploy Spring Boot to Heroku

One of the easiest ways to interact with Heroku is with the Heroku CLI. https://devcenter.heroku.com/articles/heroku-cli[Install it] before proceeding with the instructions below.

[source,shell]
----
brew tap heroku/brew && brew install heroku
----

Open a terminal and log in to your Heroku account.

[source,shell]
----
heroku login
----

Heroku expects you to have one Git repo per application. However, in this particular example, there are multiple apps in the same repo. This is called a "monorepo", where many projects are stored in the same repository.

Luckily, there's a https://elements.heroku.com/buildpacks/lstoll/heroku-buildpack-monorepo[heroku-buildpack-monorepo] that allows you to deploy multiple apps from the same repo.

You should already have a Heroku app that you added Okta to. Let's use it for hosting Spring Boot. Run `heroku apps` and you'll see the one you created.

[source,shell]
----
$ heroku apps
=== matt.raible@okta.com Apps
bootiful-angular
----

You can run `heroku config -a $APP_NAME` to see your Okta variables. In my case, I'll be using `bootiful-angular` for `$APP_NAME`.

Associate your existing Git repo with the app on Heroku.

[source,shell]
----
heroku git:remote -a $APP_NAME
----

Set the `APP_BASE` config variable to point to the `notes-api` directory. While you're there, add the monorepo and Gradle buildpacks.

[source,shell]
----
heroku config:set APP_BASE=notes-api
heroku buildpacks:add https://github.com/lstoll/heroku-buildpack-monorepo
heroku buildpacks:add heroku/gradle
----

Attach a PostgreSQL database to your app.

[source,shell]
----
heroku addons:create heroku-postgresql
----

As part of this process, Heroku will create a `DATASOURCE_URL` configuration variable. It will also automatically detect Spring Boot and set variables for `SPRING_DATASOURCE_URL`, `SPRING_DATASOURCE_USERNAME`, AND `SPRING_DATASOURCE_PASSWORD`. These values will override what you have in `application-prod.properties`.

By default, https://devcenter.heroku.com/articles/deploying-gradle-apps-on-heroku[Heroku's Gradle support] runs `./gradlew build -x test`. Since you want it to run `./gradlew bootJar -Pprod`, you'll need to override it by setting a `GRADLE_TASK` config var.

[source,shell]
----
heroku config:set GRADLE_TASK="bootJar -Pprod"
----

The `$OKTA_*` environment variables don't have the same names as the Okta Spring Boot starter expects. This is because the Okta Heroku Add-On creates two apps: SPA and web. The web app's config variables end in `_WEB`. You'll have to make some changes so those variables are used for the Okta Spring Boot starter. One way to do so is to create a `Procfile` in the `notes-api` directory.

[source,shell]
----
web: java -Dserver.port=$PORT -Dokta.oauth2.client-id=${OKTA_OAUTH2_CLIENT_ID_WEB} -Dokta.oauth2.client-secret=${OKTA_OAUTH2_CLIENT_SECRET_WEB} -jar build/lib/*.jar
----

I think it's easier to rename the variable, so that's what I recommend. Run the following command and remove `_WEB` from the two variables that have it.

[source,shell]
----
heroku config:edit
----

Now you're ready to deploy! Take a deep breath and witness how Heroku can deploy your Spring Boot + Kotlin app with a simple `git push`.

[source,shell]
----
git push heroku master
----

When I ran this command, I received this output:

[source,shell]
----
remote: Compressing source files... done.
remote: Building source:
remote:
remote: -----> Monorepo app detected
remote:       Copied notes-api to root of app successfully
remote: -----> Gradle app detected
remote: -----> Spring Boot detected
remote: -----> Installing JDK 1.8... done
remote: -----> Building Gradle app...
remote: -----> executing ./gradlew bootJar -Pprod
remote:        Downloading https://services.gradle.org/distributions/gradle-6.0.1-bin.zip
remote:        ..........................................................................................
remote:        > Task :compileKotlin
remote:        > Task :compileJava NO-SOURCE
remote:        > Task :processResources
remote:        > Task :classes
remote:        > Task :bootJar
remote:
remote:        BUILD SUCCESSFUL in 1m 28s
remote:        3 actionable tasks: 3 executed
remote: -----> Discovering process types
remote:        Procfile declares types     -> (none)
remote:        Default types for buildpack -> web
remote:
remote: -----> Compressing...
remote:        Done: 91.4M
remote: -----> Launching...
remote:        Released v1
remote:        https://bootiful-angular.herokuapp.com/ deployed to Heroku
remote:
remote: Verifying deploy... done.
To https://git.heroku.com/bootiful-angular.git
   a1b10c4..6e298cf  master -> master
Execution time: 2 min. 7 s.
----

Run `heroku open` to open your app. You'll be redirected to Okta to authenticate, then back to your app. It will display a 404 error message because you have nothing mapped to `/`. You can fix that by adding a `HomeController` with the following code.

[source,kotlin]
----
package com.okta.developer.notes

import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.core.oidc.user.OidcUser
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class HomeController {

    @GetMapping("/")
    fun hello(@AuthenticationPrincipal user: OidcUser): String {
        return "Hello, ${user.fullName}"
    }
}
----

Commit this change and deploy it to Heroku.

[source,shell]
----
git commit -am "Add HomeController"
git push heroku master
----

Now when you access the app, it should say hello.

image::{% asset_path 'blog/angular-deployment/heroku-hello.png' %}[alt=Hello, SUPER ADMIN,width=800,align=center]

== Deploy Angular to Heroku

An Angular app is composed of JavaScript, CSS, and HTML when built for production. It's extremely portable because it's just a set of static files. If you run `ng build --prod`, the production-ready files will be created in `dist/<app-name>`. In this section, you'll learn how you can use your `package.json` scripts to hook into Heroku's lifecycle and how to deploy them with a simple `git push`.

You'll need to create another app on Heroku for the Angular frontend.

[source,shell]
----
heroku create
----

Set the `APP_BASE` config variable and add the necessary buildpacks to the app that was just created.

[source,shell]
----
APP_NAME=<app-name-from-heroku-create>
heroku config:set APP_BASE=notes -a $APP_NAME
heroku buildpacks:add https://github.com/lstoll/heroku-buildpack-monorepo -a $APP_NAME
heroku buildpacks:add heroku/nodejs -a $APP_NAME
----

Change `notes/package.json` to have a different `start` script.

[source,json]
----
"start": "http-server-spa dist/notes index.html $PORT",
----

Add a `heroku-postbuild` script to your `package.json`:

[source,json]
----
"heroku-postbuild": "ng build --prod && npm install -g http-server-spa"
----

Commit your changes, add a new Git remote for this app, and deploy!

[source,shell]
----
git commit -am "Prepare for Heroku"
git remote add angular https://git.heroku.com/$APP_NAME.git
git push angular master
----

When it finishes deploying, you can open your Angular app with:

[source,shell]
----
heroku open --remote angular
----

NOTE: If you experience any issues, you can run `heroku logs --remote angular` to see your app's log files.

You won't be able to log in to your app until you modify its Login redirect URI on Okta. Log in to your Okta dashboard (tip: you can do this from the first Heroku app you created, under the **Resources** tab). Go to **Applications** > **SPA** > **General** > **Edit**. Add `https://<angular-app-on-heroku>.herokuapp.com/callback` to the Login redirect URIs and `https://<angular-app-on-heroku>.herokuapp.com` to the Logout redirect URIs.

You should be able to log in now, but you won't be able to add any notes. This is because you need to update the allowed origins in your Spring Boot app. Run the following command to add an `ALLOWED_ORIGINS` variable in your Spring Boot app.

[source,shell]
----
heroku config:set ALLOWED_ORIGINS=https://$APP_NAME.herokuapp.com --remote heroku
----

Now you should be able to add a note. Pat yourself on the back for a job well done!

One issue you'll experience is that you're going to lose your data between restarts. This is because Hibernate is configured to update your database schema each time. Change it to simply validate your schema by overriding the `ddl-auto` value in `application-prod.properties`.

[source,shell]
----
heroku config:set SPRING_JPA_HIBERNATE_DDL_AUTO=validate --remote heroku
----

== Make Your Angular App More Secure on Heroku

You've deployed your app to Heroku, but there are still a couple of security issues. The first is that if you access it using `http` (instead of `https`), it won't work. You'll get a blank page and an error from the Okta Angular SDK in your browser's console.

The second issue is that you'll score an **F** when you test it using https://securityheaders.com[securityheaders.com]. Heroku has a https://blog.heroku.com/using-http-headers-to-secure-your-site[blog post on using HTTP headers to secure your site] that will help you improve your score.

Create a `notes/static.json` file with the configuration for secure headers and redirect all HTTP requests to HTTPS.

[source,json]
.notes/static.json
----
{
  "headers": {
    "/**": {
      "Content-Security-Policy": "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'; connect-src 'self' https://*.okta.com https://*.herokuapp.com",
      "Referrer-Policy": "no-referrer, strict-origin-when-cross-origin",
      "Strict-Transport-Security": "max-age=63072000; includeSubDomains",
      "X-Content-Type-Options": "nosniff",
      "X-Frame-Options": "DENY",
      "X-XSS-Protection": "1; mode=block",
      "Feature-Policy": "accelerometer 'none'; camera 'none'; microphone 'none'"
    }
  },
  "https_only": true,
  "root": "dist/notes/",
  "routes": {
    "/**": "index.html"
  }
}
----

For `static.json` to be read, you have to use the https://github.com/heroku/heroku-buildpack-static[Heroku static buildpack]. This buildpack is made for SPA applications, so you can revert the `scripts` section of your `package.json` back to what you had previously. Add `--prod` to the `build` script since the static buildback uses this command.

[source,json]
.notes/package.json
----
"scripts": {
  "ng": "ng",
  "start": "ng serve",
  "build": "ng build --prod",
  "test": "ng test",
  "lint": "ng lint",
  "e2e": "ng e2e"
},
----

Commit your changes to Git, add the static buildpack, and redeploy your Angular app.

[source,shell]
----
git add .
git commit -am "Configure secure headers and static buildpack"
heroku buildpacks:add https://github.com/heroku/heroku-buildpack-static.git --remote angular
git push angular master
----

💥 Now you'll have a security report you can be proud of! 😃

image::{% asset_path 'blog/angular-deployment/heroku-headers.png' %}[alt=Security Report Summary with an A,width=800,align=center]

== Angular Deployment with `ng deploy`

In Angular CLI v8.3.0, an `ng deploy` command was introduced that allows you to automate deploying to many different cloud providers. I thought it'd be fun to try a few of these out and see if it's possible to optimize the headers to get the same **A** rating that you were able to get with Heroku.

Below are the https://angular.io/guide/deployment[current providers and packages] supported by this command.

|===
|Hosting provider |npm package

|Azure
|https://npmjs.org/package/@azure/ng-deploy[`@azure/ng-deploy`]

|AWS S3
|https://www.npmjs.com/package/@jefiozie/ngx-aws-deploy[`@jefiozie/ngx-aws-deploy`]

|Firebase
|https://npmjs.org/package/@angular/fire[`@angular/fire`]

|GitHub pages
|https://npmjs.org/package/angular-cli-ghpages[`angular-cli-ghpages`]

|Netlify
|https://www.npmjs.com/package/@netlify-builder/deploy[`@netlify-builder/deploy`]

|Now
|https://npmjs.org/package/@zeit/ng-deploy[`@zeit/ng-deploy`]

|NPM
|https://npmjs.org/package/ngx-deploy-npm[`ngx-deploy-npm`]

|===

In the following section, I'll show you how to deploy to a few that piqued my interest (Firebase, Netlify, and AWS S3).

=== Angular Deployment to Firebase

Create a `firebase` branch so you can make changes without affecting the work you've done for Heroku deployments.

[source,shell]
----
git checkout -b firebase
----

Open a browser and go to https://firebase.google.com/[firebase.google.com]. Log in to your account, go to the console, and create a new project.

Run `ng add @angular/fire` in the `notes` directory and your new project should show up in the list. Select it to continue.

[source,shell]
----
? Please select a project: ng-notes-1337 (ng-notes-1337)
CREATE firebase.json (300 bytes)
CREATE .firebaserc (133 bytes)
UPDATE angular.json (3755 bytes)
----

Now you can run `ng deploy` and everything should work.

You'll need to add the project's URL as an allowed origin in your Spring Boot app on Heroku. Copy the printed `Hosting URL` value and run the following command.

[source,shell]
----
heroku config:edit --remote heroku
----

Add the new URL after your existing Heroku one, separating them with a comma. For example:

[source,shell]
----
ALLOWED_ORIGINS='https://stark-lake-39546.herokuapp.com,https://ng-notes-1337.web.app'
----

You'll also need to modify your Okta SPA app to add your Firebase URL as a Login redirect URI and Logout redirect URI. For mine, I added:

* Login redirect URI: `\https://ng-notes-1337.web.app/callback`
* Logout redirect URI: `\https://ng-notes-1337.web.app`

Open your Firebase URL in your browser, log in, and you should be able to see the note you added on Heroku.

=== Strong Security Headers on Firebase

If you test your new Firebase site on https://securityheaders.com/[securityheaders.com], you'll score a **D**. Luckily, you can https://firebase.google.com/docs/hosting/full-config#headers[configure headers] in your `firebase.json` file. Edit this file and add a `headers` key like the following:

[source,json]
----
"headers": [ {
  "source": "/**",
  "headers": [
    {
      "key": "Content-Security-Policy",
      "value": "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'; connect-src 'self' https://*.okta.com https://*.herokuapp.com"
    },
    {
      "key": "Referrer-Policy",
      "value": "no-referrer, strict-origin-when-cross-origin"
    },
    {
      "key": "X-Content-Type-Options",
      "value": "nosniff"
    },
    {
      "key": "X-Frame-Options",
      "value": "DENY"
    },
    {
      "key": "X-XSS-Protection",
      "value": "1; mode=block"
    },
    {
      "key": "Feature-Policy",
      "value": "accelerometer 'none'; camera 'none'; microphone 'none'"
    }
  ]
} ]
----

NOTE: You don't need to include a `Strict-Transport-Security` header because Firebase includes it by default.

Run `ng deploy` and you should get an **A** now!

image::{% asset_path 'blog/angular-deployment/firebase-headers.png' %}[alt=Firebase app score from securityheaders.com,width=800,align=center]

Commit your changes to your `firebase` branch.

[source,shell]
----
git add .
git commit -am "Add Firebase deployment"
----

=== Angular Deployment to Netlify

Netlify is a hosting provider for static sites that I've enjoyed using in the past. They offer continuous integration, HTML forms, AWS Lambda functions, and CMS functionality. I wrote about Netlify in link:/blog/2020/02/18/gatsby-react-netlify[Build a Secure Blog with Gatsby, React, and Netlify].

Check out your `master` branch and create a new `netlify` one.

[source,shell]
----
git checkout master
git checkout -b netlify
----

Before running the command to add Netlify support, you'll need to https://app.netlify.com/signup[create a Netlify account]. Once you're signed in, create a new site. Netlify makes it easy to connect a site via Git, but since I want to demonstrate `ng deploy`, you'll need to create a temporary directory with an `index.html` file in it. I put "Hello, World" in the HTML file, then dragged the directory into my browser window.

image::{% asset_path 'blog/angular-deployment/netlify-create-site.png' %}[alt=Netlify create site,width=650,align=center]

Click on **Site Settings** to copy your **API ID** to a text editor. You'll also need a personal access token. To create one, click on your avatar in the top right > **User settings** > **Applications** and click **New access token**. Copy the generated token to your text editor.

Run the command below to add Netlify deployment support.

[source,shell]
----
ng add @netlify-builder/deploy
----

Copy and paste your API ID and personal access token when prompted, then run `ng deploy` to deploy your site.

Update your Spring Boot app on Heroku to allow your Netlify app URL:

[source,shell]
----
heroku config:edit --remote heroku
----

Make sure to append the URL to your existing ones, separating them with a comma.

[source,shell]
----
ALLOWED_ORIGINS='https://stark-lake-39546.herokuapp.com,https://ng-notes-1337.web.app,https://relaxed-brown-0b81d8.netlify.app'
----

You'll also need to update your Okta app to whitelist the URL as a login and logout redirect.

If you try to log in, you'll get a `Page Not Found` error stemming from Okta trying to redirect back to your app. This happens because Netlify doesn't know your app is a SPA that manages its own routes. To fix this, create a `_redirects` file in the `notes/src` directory with the following contents.

[source,shell]
----
/*    /index.html   200
----

TIP: You can learn more about https://docs.netlify.com/routing/redirects/rewrites-proxies/#history-pushstate-and-single-page-apps[configuring Netlify for SPAs in their documentation].

Then, modify `angular.json` to include this file in its assets.

[source,json]
----
"assets": [
  "src/_redirects",
  "src/favicon.ico",
  "src/assets"
],
----

Run `ng deploy` again and you should be able to log in successfully.

=== Better Security Headers on Netlify

If you test your new Firebase site on https://securityheaders.com/[securityheaders.com], you'll score a **D**. Netlify allows you to add https://docs.netlify.com/routing/headers/[custom headers] to improve your score.

Create a `src/_headers` file with the following contents.

[source,text]
----
/*
  Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'; connect-src 'self' https://*.okta.com https://*.herokuapp.com
  Referrer-Policy: no-referrer, strict-origin-when-cross-origin
  X-Content-Type-Options: nosniff
  X-Frame-Options: DENY
  X-XSS-Protection: 1; mode=block
  Feature-Policy: accelerometer 'none'; camera 'none'; microphone 'none'
----

NOTE: You don't need to include a `Strict-Transport-Security` header because Netlify includes one by default.

Modify `angular.json` to include this file in its assets.

[source,json]
----
"assets": [
  "src/_headers",
  "src/_redirects",
  "src/favicon.ico",
  "src/assets"
],
----

Run `ng deploy` and you should get an **A** now!

image::{% asset_path 'blog/angular-deployment/netlify-headers.png' %}[alt=Netlify score from securityheaders.com,width=800,align=center]

Commit your changes to the `netlify` branch.

[source,shell]
----
git add .
git commit -am "Add Netlify deployment"
----

[WARNING]
====
The Netlify schematic writes your access token to `angular.json`, which is a security risk (if you push these changes to your source control system).

[source,json]
----
"deploy": {
  "builder": "@netlify-builder/deploy:deploy",
  "options": {
    "outputPath": "dist/notes",
    "netlifyToken": "04b966f772XXX...",
    "siteId": "1dda959c-XXXX..."
  }
}
----

I was notified of this issue by https://gitguardian.com/[GitGuardian], which we use to monitor our repos. If you check-in this change, make sure to delete the access token on Netlify.
====

=== Angular Deployment to AWS S3

Amazon Simple Storage Service (Amazon S3) is an object storage service that is a popular option for hosting static sites.

Check out your `master` branch and create a new `aws` one.

[source,shell]
----
git checkout master
git checkout -b aws
----

Before running the command to add S3 deployment support, you'll need a few things:

* An S3 Bucket
* An AWS Region Name
* A Secret Access Key
* An Access Key ID

You'll also need to https://portal.aws.amazon.com/billing/signup[create an AWS account]. After creating an account, go to the https://s3.console.aws.amazon.com/[Amazon S3 console]. Click **Create Bucket** and give it a name you'll remember. Use the default region selected for you and click **Create Bucket**.

To create the secret access key, go to your https://console.aws.amazon.com/iam/home?nc2=h_m_sc#/security_credentials[security credentials page]. Expand the **Access keys** section, and then **Create New Access Key**. Click **Show Access Key** and copy the values into a text editor.

TIP: If you have trouble creating a secret access key, see https://aws.amazon.com/blogs/security/how-to-find-update-access-keys-password-mfa-aws-management-console/[this blog post].

Add the `@jefiozie/ngx-aws-deploy` package to deploy to S3:

[source,shell]
----
ng add @jefiozie/ngx-aws-deploy
----

When prompted, enter your region, bucket name, access key, and access key ID. When prompted for the folder, leave it blank.

CAUTION: This process writes these raw values to your `angular.json`. For a more secure setup, use environment variables: `NG_DEPLOY_AWS_ACCESS_KEY_ID`, `NG_DEPLOY_AWS_SECRET_ACCESS_KEY`, `NG_DEPLOY_AWS_BUCKET` and `NG_DEPLOY_AWS_REGION`.

Run `ng deploy` to deploy your Angular app to your AWS S3 bucket.

Next, you need to https://docs.aws.amazon.com/AmazonS3/latest/user-guide/static-website-hosting.html[configure S3 for static website hosting]. Go to your bucket > **Properties** > **Static website hosting**. Take note of the endpoint URL at the top of the card, you'll need this in a minute.

Type `index.html` for the index and error document and click **Save**.

image::{% asset_path 'blog/angular-deployment/aws-static-website.png' %}[alt=AWS static website,width=500,align=center]

By default, Amazon S3 blocks public access to your buckets. Go to the **Permissions** tab. Click the **Edit** button, clear **Block all public access**, and click **Save**.

The last step you need to do to make it public is add a bucket policy. Go to **Permissions** > **Bucket Policy** and paste the following into the editor, replacing `{your-bucket-name}` with your bucket's name.

[source,json]
----
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "PublicReadGetObject",
            "Effect": "Allow",
            "Principal": "*",
            "Action": [
                "s3:GetObject"
            ],
            "Resource": [
                "arn:aws:s3:::{your-bucket-name}/*"
            ]
        }
    ]
}
----

Click **Save** to continue.

At this point, you could navigate to `\https://<bucket-name>.s3.amazonaws.com/index.html` in your browser, and the application will load. However, there's no HTTP to HTTPS redirect or resolution of `index.html` by default. You can https://aws.amazon.com/premiumsupport/knowledge-center/cloudfront-https-requests-s3/[use CloudFront to solve these issues].

Open the https://console.aws.amazon.com/cloudfront/[CloudFront console] and choose **Create Distribution**. Under the Web section, click the **Get Started** button. Click in the **Origin Domain Name** field and select your S3 bucket.

Set the **Viewer Protocol Policy** to `Redirect HTTP to HTTPS`, allow all HTTP methods, and enter `index.html` as the **Default Root Object**. Scroll to the bottom and click **Create Distribution**. When the Status column changes from `In Progress` to `Deployed`, navigate to the domain name in your browser.

NOTE: Once you've created your distribution, it can take 20 minutes for it to deploy.

After your distribution is deployed, update your Spring Boot app on Heroku to allow your CloudFront URL:

[source,shell]
----
heroku config:edit --remote heroku
----

Make sure to append the URL to your existing ones, separating them with a comma.

[source,shell]
----
ALLOWED_ORIGINS='https://stark-lake-39546.herokuapp.com,https://ng-notes-1337.web.app,https://relaxed-brown-0b81d8.netlify.app,https://d2kytj28ukuxfr.cloudfront.net'
----

Update your Okta SPA app to whitelist the URL as a redirect, too.

If you try to log in, you'll get a 403 when redirecting back to the site. To fix this, edit your distribution > **Error pages**. Create two custom error responses for `404` and `403`. Return a path of `/index.html` and a `200: OK` response code.

Now you should be able to authenticate to your Angular app on AWS successfully!

=== Awesome Security Headers with AWS CloudFront + S3

If you test your new CloudFront + S3 site on https://securityheaders.com/[securityheaders.com], you'll get an **F**. To solve this, you can use https://aws.amazon.com/blogs/networking-and-content-delivery/adding-http-security-headers-using-lambdaedge-and-amazon-cloudfront/[Lambda@Edge to add security headers].

Go to the https://us-west-2.console.aws.amazon.com/lambda/home[Lambda Console] and select the `US-East-1 N` region from a drop-down list in the top right. Click **Create Function** to create a new function.

Choose **Author from scratch** and name it `securityHeaders`. Under Permissions, select **Create a new role from AWS Policy templates**. Name the role `securityHeaders-role` and select **Basic Lambda@Edge permissions (for CloudFront trigger)**. Click **Create function**.

In the Function code section, set `index.js` to have the following JavaScript.

[source,js]
----
exports.handler = (event, context, callback) => {

  // get response
  const response = event.Records[0].cf.response;
  const headers = response.headers;

  // set headers
  headers['content-security-policy'] = [{key: 'Content-Security-Policy', value: "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'; connect-src 'self' https://*.okta.com https://*.herokuapp.com"}];
  headers['referrer-policy'] = [{key: 'Referrer-Policy', value: 'no-referrer, strict-origin-when-cross-origin'}];
  headers['strict-transport-security'] = [{key: 'Strict-Transport-Security', value: 'max-age=63072000; includeSubdomains'}];
  headers['x-content-type-options'] = [{key: 'X-Content-Type-Options', value: 'nosniff'}];
  headers['x-frame-options'] = [{key: 'X-Frame-Options', value: 'DENY'}];
  headers['x-xss-protection'] = [{key: 'X-XSS-Protection', value: '1; mode=block'}];
  headers['feature-policy'] = [{key: 'Feature-Policy', value: "accelerometer 'none'; camera 'none'; microphone 'none'"}];

  // return modified response
  callback(null, response);
};
----

Click **Save** and add a trigger. Select **CloudFront** and **Deploy to Lambda@Edge**. For the distribution, use the ID of your CloudFront distribution. Set the event to be **Origin response**. Select the "I acknowledge..." checkbox and click **Deploy**.

Go back to your CloudFront Console and wait for the deploy to complete.

Try your CloudFront domain again on https://securityheaders.com[securityheaders.com]. You should get an **A** this time.

image::{% asset_path 'blog/angular-deployment/aws-headers.png' %}[alt=AWS score from securityheaders.com,width=800,align=center]

_Phew! AWS certainly doesn't make things easy._

Commit your changes to the `aws` branch.

[source,shell]
----
git commit -am "Add AWS S3 deployment"
----

WARNING: If you committed the changes in your `angular.json` file, you should delete your access key in **My Account** > **Security Credentials**. When I made this mistake, Amazon emailed me right away and made me delete my access key and change my password.

== Learn More About Angular and Spring Boot

In this tutorial, you learned how to upgrade Angular and Spring Boot to their latest versions and make them production-ready. You used the https://devcenter.heroku.com/articles/okta[Okta add-on for Heroku] to add OAuth 2.0 + OIDC to both apps, then deployed them to Heroku. After you got them working on Heroku with PostgreSQL, you learned how to deploy the Angular app to Firebase, Netlify, and AWS.

You learned how to make your Angular app more secure with security headers, force HTTPS, and make each cloud provider SPA-aware. You can find the source code for the completed example in the https://github.com/oktadeveloper/okta-angular-deployment-example[@oktadeveloper/okta-angular-deployment-example] repository.

This blog post is the third in a series. The first two posts are below.

1. link:/blog/2020/01/06/crud-angular-9-spring-boot-2[Build a CRUD App with Angular 9 and Spring Boot 2.2]
2. link:/blog/2020/03/02/angular-bootstrap[Build Beautiful Angular Apps with Bootstrap]

I'll be publishing a link:/blog/2020/06/17/angular-docker-spring-boot[4th and final blog post that shows you how to containerize and deploy your Angular + Spring Boot apps with Docker]. This tutorial will also show how to combine them into a JAR and use server-side authorization code flow (the most secure OAuth 2.0 flow). As icing on the cake, I'll show you how to deploy to Heroku, Knative on Google Cloud, and Cloud Foundry!

If you liked this tutorial, we have several others on Angular and Spring Boot.

- link:/blog/2020/01/21/angular-material-login[Build a Beautiful App + Login with Angular Material]
- link:/blog/2020/06/17/angular-docker-spring-boot[Angular + Docker with a Big Hug from Spring Boot]
- link:/blog/2020/02/12/angular-ivy[What Is Angular Ivy and Why Is It Awesome?]
- link:/blog/2019/10/30/java-oauth2[OAuth 2.0 Java Guide: Secure Your App in 5 Minutes]
- link:/blog/2019/05/15/spring-boot-login-options[A Quick Guide to Spring Boot Login Options]
- link:/blog/2019/09/17/build-a-spring-boot-kotlin-app[Build an Application with Spring Boot and Kotlin]

If you have any questions, please leave a comment below. Follow us on https://twitter.com/oktadev[Twitter], https://www.linkedin.com/company/oktadev[LinkedIn], or https://www.facebook.com/oktadevelopers/[Facebook] to be notified when we publish new tutorials. We have a popular https://youtube.com/c/oktadev[YouTube channel] too!


== Angular Docker

Building modern apps with Angular and Spring Boot is a common practice these days. In fact, if I use Google's Keyword Planner to look up popular search terms, it's one of the most popular combinations. The results in the list below are average monthly searches and not limited by location.

image::{% asset_path 'blog/angular-docker/keyword-planner-angular-results.png' %}[alt=Keyword Planner results,width=375,align=center]

This tutorial is the fourth and final in a series on Angular and Spring Boot in 2020. In the first one, I showed how to create a secure notes app with Angular and Spring Boot + Kotlin. The second showed how to add Bootstrap for CSS and create a sortable, searchable, and pageable data table. The third showed how to deploy apps separately to Heroku. It also outlined how it's possible to use `ng deploy` to deploy to Firebase, Netlify, and AWS. You can find links to previous tutorials below.

1. link:/blog/2020/01/06/crud-angular-9-spring-boot-2[Build a CRUD App with Angular 9 and Spring Boot 2.2]
2. link:/blog/2020/03/02/angular-bootstrap[Build Beautiful Angular Apps with Bootstrap]
3. link:/blog/2020/05/29/angular-deployment[Angular Deployment with a Side of Spring Boot]

Today, I'll show you how to use Docker to create an image for your Angular app and deploy it to Heroku. Then, I'll show how to combine Angular and Spring Boot into the same JAR artifact for deployment. You'll learn how to Dockerize the combined apps using Jib and Cloud Native Buildpacks. Finally, I'll show you how to deploy your Docker image to Heroku, Knative on Google Cloud, and Cloud Foundry.

image::{% asset_path 'blog/angular-docker/angular-docker-spring-boot-hug.png' %}[alt=Angular + Docker with a Big Hug from Spring Boot,width=800,align=center]

Docker is the most popular way to build and share containers. _Dockerizing_ involves packaging your app—you can also include web servers to serve up your app. This is important when containerizing an Angular app because its artifacts are just JavaScript, CSS, and HTML; the production app is static files that will need to be served up by some sort of web server. As an added bonus, you can configure the web server to send security headers that make your app more secure.

toc::[]

====
I'd like to thank many folks for their help with this post. **Benoit Sautel** for help with Gradle + Kotlin, **Ray Tsang** for help with Jib, **James Ward** for help with Knative, **Josh Long** for his assistance with Docker + Cloud Foundry, and **Joe Kutner** for his buildpacks support. Y'all rock! 🤘

[.avatar-row]
https://twitter.com/bsautel[image:{% asset_path 'blog/angular-docker/bsautel.jpg' %}[alt=Benoit Sautel,role="BlogPost-avatar img-100px"]]
https://twitter.com/saturnism[image:{% asset_path 'blog/angular-docker/saturnism.jpg' %}[alt=Ray Tsang,role="BlogPost-avatar img-100px"]]
https://twitter.com/_JamesWard[image:{% asset_path 'blog/angular-docker/_JamesWard.jpg' %}[alt=James Ward,role="BlogPost-avatar img-100px"]]
https://twitter.com/starbuxman[image:{% asset_path 'blog/angular-docker/starbuxman.jpg' %}[alt=Josh Long,role="BlogPost-avatar img-100px"]]
https://twitter.com/codefinger[image:{% asset_path 'blog/angular-docker/codefinger.jpg' %}[alt=Joe Kutner,role="BlogPost-avatar img-100px"]]
====

NOTE: You can also https://youtu.be/BKepFaIwCvo[watch this tutorial as a screencast]!

++++
<div style="text-align: center; margin-bottom: 1.25rem">
<iframe width="700" height="394" style="max-width: 100%" src="https://www.youtube.com/embed/BKepFaIwCvo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
++++

== Create an Angular + Spring Boot App

To begin, clone the GitHub repo from the link:/blog/2020/05/29/angular-deployment[most recent tutorial] in this series.

[source,shell]
----
git clone https://github.com/oktadeveloper/okta-angular-deployment-example.git \
 angular-spring-boot-docker
----

**Prerequisites:**

* https://docs.docker.com/install/[Docker]
* https://nodejs.org/[Node.js] 12+
* https://adoptopenjdk.net/[Java] 8+
* An https://developer.okta.com/signup/[Okta Developer Account]

=== Secure Your Angular + Spring Boot App with OpenID Connect

OAuth 2.0 was finalized in 2012 and has since become the industry-standard protocol for authorization. In 2014, OpenID Connect (OIDC) extended OAuth, adding federated identity to delegated authorization. Together, these two layers offer a standard specification that developers can write code against in a way that will work across multiple identity providers.

To begin the process of adding OIDC to Angular and Spring Boot, you'll need to https://signup.heroku.com/login[create a Heroku account]. If you already have a Heroku account, https://id.heroku.com/login[log into it]. Once you're logged in, create a new app. I named mine `bootiful-angular`.

image::{% asset_path 'blog/angular-docker/heroku-create-app.png' %}[alt=Create Heroku app,width=700,align=center]

After creating your app, click on the **Resources** tab and add the **Okta** add-on.

image::{% asset_path 'blog/angular-docker/okta-add-on.png' %}[alt=Okta Add-On,width=475,align=center]

CAUTION: If you haven't entered a credit card for your Heroku account, you will get an error. This is because Heroku requires you to have a credit card on file to use any of their add-ons, even free ones. This is part of Heroku's assurance to guard against misuse (real person, real credit card, etc.). I think this is a good security practice. Add a credit card to continue.

Click **Provision** and wait 20-30 seconds while your Okta account is created and OIDC apps are registered. Now go to your app's **Settings** tab and click the **Reveal Config Vars** button. The variables displayed are the environment variables you can use to configure both Angular and Spring Boot for OIDC authentication.

image::{% asset_path 'blog/angular-docker/heroku-config-vars.png' %}[alt=Okta Add-On,width=800,align=center]

Create an `okta.env` file in the `angular-spring-boot-docker/notes-api` directory and copy the variable values into it, where `$OKTA_*` is the value from Heroku.

[source,shell]
----
export OKTA_OAUTH2_ISSUER=$OKTA_OAUTH2_ISSUER
export OKTA_OAUTH2_CLIENT_ID=$OKTA_OAUTH2_CLIENT_ID_WEB
export OKTA_OAUTH2_CLIENT_SECRET=$OKTA_OAUTH2_CLIENT_SECRET_WEB
----

[NOTE]
====
If you're on Windows without https://docs.microsoft.com/en-us/windows/wsl/install-win10[Windows Subsystem for Linux] installed, create an `okta.bat` file and use `SET` instead of `export`.
====

Start your Spring Boot app by navigating to the `notes-api` directory, sourcing this file, and running `bootRun`.

[source,shell]
----
source okta.env
./gradlew bootRun
----

For Windows users, the commands will be:

[source,shell]
----
okta.bat
gradlew bootRun
----

Next, configure Angular for OIDC authentication by modifying its `auth-routing.module.ts` to use the generated issuer and **SPA** client ID.

[source,typescript]
.notes/src/app/auth-routing.module.ts
----
const oktaConfig = {
  issuer: '$OKTA_OAUTH2_ISSUER',
  redirectUri: window.location.origin + '/callback',
  clientId: '$OKTA_OAUTH2_CLIENT_ID_SPA',
  pkce: true
};
----

Install your Angular app's dependencies and start it.

[source,shell]
----
npm i
ng serve
----

Open `http://localhost:4200` in your browser.

image::{% asset_path 'blog/angular-docker/angular-home.png' %}[alt=Angular Home,width=800,align=center]

Click the **Login** button in the top right corner. You should be logged in without seeing a login form because you're already logged in to Okta. If you want to see the full authentication flow, log out, or try it in a private window. You can use the `$OKTA_ADMIN_EMAIL` and `$OKTA_ADMIN_PASSWORD` from your Heroku config variables for credentials. Create a note to make sure everything works.

Commit your progress to Git from the top-level `angular-spring-boot-docker` directory.

[source,shell]
----
git commit -am "Add Okta OIDC Configuration"
----

== Create a Docker Container for Your Angular App

Create a `notes/Dockerfile` that uses Node and Nginx as a web server.

[source,docker]
----
FROM node:14.1-alpine AS builder

WORKDIR /opt/web
COPY package.json package-lock.json ./
RUN npm install

ENV PATH="./node_modules/.bin:$PATH"

COPY . ./
RUN ng build --prod

FROM nginx:1.17-alpine
COPY nginx.config /etc/nginx/conf.d/default.conf
COPY --from=builder /opt/web/dist/notes /usr/share/nginx/html
----

[NOTE]
====
When I was trying to get everything to work, I found it handy to comment out the `RUN ng build --prod` line and use the following instead.

[source,shell]
----
RUN mkdir -p dist/notes
RUN echo "Hello, World" > dist/notes/index.html
----

This allows you to skip the lengthy Angular build process.
====

This will build your project and add Nginx as a web server. You'll need to create the `nginx.config` file to make Nginx SPA-aware.

[source,config]
.notes/nginx.config
----
server {
    listen   80;
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri /index.html;
    }
}
----

Make sure your Docker daemon is running with `docker ps`. Then run the following command to build your Docker image. The `ng-notes` value can be whatever you want to name your image.

[source,shell]
----
docker build -t ng-notes .
----

If it builds successfully, you'll see messages like the following:

[source,shell]
----
Successfully built 382b9cd7d345
Successfully tagged ng-notes:latest
----

You can run it locally on port 4200 using the `docker run` command.

[source,shell]
----
docker run -p 4200:80 ng-notes
----

Add these Docker commands as scripts to your `package.json` file.

[source,json]
----
"docker": "docker build -t ng-notes .",
"ng-notes": "docker run -p 4200:80 ng-notes"
----

The `docker run` command will serve up the production version of the Angular app, which has its backend configured to point to a production URL on Heroku.

[source,typescript]
.notes/src/environments/environment.prod.ts
----
export const environment = {
  production: true,
  apiUrl: 'https://bootiful-angular.herokuapp.com'
};
----

You'll need to deploy your Spring Boot app to a similar public URL for your Angular + Docker container to work in production.

NOTE: If you already deployed Spring Boot to Heroku (from the last tutorial), you can skip the next section and go straight to deploying your Angular Docker container to Heroku.

=== Deploy Spring Boot to Heroku

One of the easiest ways to interact with Heroku is with the Heroku CLI. https://devcenter.heroku.com/articles/heroku-cli[Install it] before proceeding with the instructions below.

[source,shell]
----
brew tap heroku/brew && brew install heroku
----

Open a terminal and log in to your Heroku account.

[source,shell]
----
heroku login
----

You should already have a Heroku app that you've added Okta to. You can use it for hosting your Spring Boot app. Run `heroku apps` and you'll see the one that you created.

[source,shell]
----
$ heroku apps
=== matt.raible@okta.com Apps
bootiful-angular
----

You can run `heroku config -a $APP_NAME` to see your Okta variables. In my case, I'll be using `bootiful-angular` for `$APP_NAME`.

Associate your existing Git repo with the app on Heroku.

[source,shell]
----
heroku git:remote -a $APP_NAME
----

Set the `APP_BASE` config variable to point to the `notes-api` directory. While you're there, add the monorepo and Gradle buildpacks.

[source,shell]
----
heroku config:set APP_BASE=notes-api
heroku buildpacks:add https://github.com/lstoll/heroku-buildpack-monorepo
heroku buildpacks:add heroku/gradle
----

Attach a PostgreSQL database to your app.

[source,shell]
----
heroku addons:create heroku-postgresql
----

By default, https://devcenter.heroku.com/articles/deploying-gradle-apps-on-heroku[Heroku's Gradle support] runs `./gradlew build -x test`. Since you want it to run `./gradlew bootJar -Pprod`, you'll need to override it by setting a `GRADLE_TASK` config var.

[source,shell]
----
heroku config:set GRADLE_TASK="bootJar -Pprod"
----

The `$OKTA_*` environment variables don't have the same names as the Okta Spring Boot starter expects. This is because the Okta Heroku Add-On creates two apps: a SPA and a web app. The web app's config variables end in `_WEB`. You'll have to make some changes so those variables are used for the Okta Spring Boot starter. Run the following command and remove `_WEB` from the two variables that have it.

[source,shell]
----
heroku config:edit
----

Now you're ready to deploy! Heroku makes this easy with a simple `git push`.

[source,shell]
----
git push heroku main:master
----

Run `heroku open` to open your app. You'll be redirected to Okta to authenticate, then back to your Spring Boot app. You should see a screen like the one below.

image::{% asset_path 'blog/angular-docker/heroku-hello.png' %}[alt=Hello on Heroku,width=800,align=center]

By default, JPA is configured to create your database schema each time. Change it to simply validate the schema.

[source,shell]
----
heroku config:set SPRING_JPA_HIBERNATE_DDL_AUTO=validate
----

Now, you'll need to configure your Angular app to use your Heroku-deployed Spring Boot app for its production URL.

[source,typescript]
.notes/src/environments/environment.prod.ts
----
export const environment = {
  production: true,
  apiUrl: 'https://<your-heroku-app>.herokuapp.com'
};
----

Since this runs the production build, you'll need to add `\http://localhost:4200` as an allowed origin in your Spring Boot app on Heroku. Run the following command and add it to the end of the existing values.

[source,shell]
----
heroku config:set ALLOWED_ORIGINS=http://localhost:4200
----

TIP: One advantage of doing this is that you can run your local Angular app against your production backend. I've found this very useful when debugging and fixing UI issues caused by production data.

Now you should be able to rebuild your Angular Docker container and run it.

[source,shell]
----
npm run docker
npm run ng-notes
----

Open your browser to `http://localhost:4200`, log in, and confirm you can add notes.

image::{% asset_path 'blog/angular-docker/first-note-on-heroku.png' %}[alt=First Note on Heroku,width=800,align=center]

Verify the data made it to Heroku by going to `\https://<your-heroku-app>.herokuapp.com/api/notes`.

== Deploy Angular + Docker to Heroku

Heroku has  https://devcenter.heroku.com/articles/container-registry-and-runtime[several slick features when it comes to Docker images]. If your project has a `Dockerfile`, you can deploy your app directly using the Heroku Container Registry.

First, make sure you're in the `notes` directory, then log in to the Container Registry.

[source,shell]
----
heroku container:login
----

Then, create a new app.

[source,shell]
----
heroku create
----

Add the Git URL as a new remote named `docker`.

[source,shell]
----
git remote add docker https://git.heroku.com/<your-app-name>.git
----

You'll need to update `nginx.config` so it reads from a `$PORT` environment variable if it's set, otherwise default it to 80. You can use https://michalzalecki.com/nginx-listen-on-port-docker/[`envsubst` to do this at runtime]. However, the default `envsubst` doesn't allow default variables. The good news is https://github.com/a8m/envsubst[a8m/envsubst] on GitHub does!

Replace your `nginx.config` with the following configuration that defaults to 80 and escapes the `$uri` variable so it's not replaced with a blank value.

[source,config]
.notes/nginx.config
----
server {
    listen       ${PORT:-80};
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $$uri /index.html;
    }
}
----

You'll also need to update your `Dockerfile` so it uses the aforementioned `envsubstr`.

[source,docker]
.notes/Dockerfile
----
FROM node:14.1-alpine AS builder

WORKDIR /opt/web
COPY package.json package-lock.json ./
RUN npm install

ENV PATH="./node_modules/.bin:$PATH"

COPY . ./
RUN ng build --prod

FROM nginx:1.17-alpine
RUN apk --no-cache add curl
RUN curl -L https://github.com/a8m/envsubst/releases/download/v1.1.0/envsubst-`uname -s`-`uname -m` -o envsubst && \
    chmod +x envsubst && \
    mv envsubst /usr/local/bin
COPY ./nginx.config /etc/nginx/nginx.template
CMD ["/bin/sh", "-c", "envsubst < /etc/nginx/nginx.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"]
COPY --from=builder /opt/web/dist/notes /usr/share/nginx/html
----

Then, push your Docker image to Heroku's Container Registry.

[source,shell]
----
heroku container:push web --remote docker
----

Once the push process has completed, release the image of your app:

[source,shell]
----
heroku container:release web --remote docker
----

And open the app in your browser:

[source,shell]
----
heroku open --remote docker
----

You'll need to add your app's URL to Okta as a valid redirect URI. In your Spring Boot app on Heroku, go to **Resources** and click on the **Ookta** add-on. This will log you in to your Okta dashboard. Navigate to **Applications** > **SPA** > **General** > **Edit**. Add the following redirect URIs.

- Login: `\https://<angular-docker-app>.herokuapp.com/callback`
- Logout: `\https://<angular-docker-app>.herokuapp.com`

You'll need to add the new app's URL as an allowed origin in your Spring Boot app on Heroku. Copy the printed `Hosting URL` value and run the following command.

[source,shell]
----
heroku config:edit --remote heroku
----

Add the new URL after your existing `localhost` one, separating them with a comma. For example:

[source,shell]
----
ALLOWED_ORIGINS='http://localhost:4200,https://<angular-docker-app>.herokuapp.com'
----

Now you should be able to log in and see the note you created earlier.

=== A-Rated Security Headers for Nginx in Docker

If you test your freshly-deployed Angular app with https://securityheaders.com/[securityheaders.com], you'll get an **F**. To solve this, modify your `nginx.config` to add security headers.

[source,config]
.notes/nginx.conf
----
server {
    listen       ${PORT:-80};
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $$uri /index.html;
    }

    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'; connect-src 'self' https://*.okta.com https://*.herokuapp.com";
    add_header Referrer-Policy "no-referrer, strict-origin-when-cross-origin";
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains";
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options DENY;
    add_header X-XSS-Protection "1; mode=block";
    add_header Feature-Policy "accelerometer 'none'; camera 'none'; microphone 'none'";
}
----

After updating this file, run the following commands:

[source,shell]
----
heroku container:push web --remote docker
heroku container:release web --remote docker
----

Now you should get an **A**!

image::{% asset_path 'blog/angular-docker/angular-docker-securityheaders.png' %}[alt=Nginx in Docker score from securityheaders.com,width=800,align=center]

Commit your changes to Git.

[source,shell]
----
git add .
git commit -m "Add Docker for Angular"
----

== Combine Your Angular + Spring Boot App into a Single JAR

In the previous sections, you learned how to deploy your Angular and Spring Boot apps separately. Now I'll show you how to combine them into a single JAR for production. You'll still be able to run them independently in development, but deploying them to production will be easier because you won't have to worry about CORS (cross-origin resource sharing). I'll also convert the OAuth flows so they all happen server-side, which is more secure as the access token won't be stored in the browser.

NOTE: Most client-side OAuth libraries keep access tokens in local storage. However, there is a https://gitlab.com/jimdigriz/oauth2-worker[oauth2-worker] project that allows you to store them in a web worker. There's also folks that think https://pragmaticwebsecurity.com/articles/oauthoidc/localstorage-xss.html[avoiding LocalStorage for tokens is the wrong solution].

=== Update Your Angular App's Authentication Mechanism

Create a new `AuthService` service that will communicate with your Spring Boot API for authentication logic.

====
[source,typescript]
.notes/src/app/shared/auth.service.ts
----
import { Injectable } from '@angular/core';
import { Location } from '@angular/common';
import { BehaviorSubject, Observable } from 'rxjs';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { User } from './user';
import { map } from 'rxjs/operators';

const headers = new HttpHeaders().set('Accept', 'application/json');

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  $authenticationState = new BehaviorSubject<boolean>(false);

  constructor(private http: HttpClient, private location: Location) {
  }

  getUser(): Observable<User> {
    return this.http.get<User>(`${environment.apiUrl}/user`, {headers}).pipe(
      map((response: User) => {
        if (response !== null) {
          this.$authenticationState.next(true);
          return response;
        }
      })
    );
  }

  isAuthenticated(): Promise<boolean> {
    return this.getUser().toPromise().then((user: User) => { // <1>
      return user !== undefined;
    }).catch(() => {
      return false;
    })
  }

  login(): void { // <2>
    location.href =
      `${location.origin}${this.location.prepareExternalUrl('oauth2/authorization/okta')}`;
  }

  logout(): void { // <3>
    const redirectUri = `${location.origin}${this.location.prepareExternalUrl('/')}`;

    this.http.post(`${environment.apiUrl}/api/logout`, {}).subscribe((response: any) => {
      location.href = response.logoutUrl + '?id_token_hint=' + response.idToken
        + '&post_logout_redirect_uri=' + redirectUri;
    });
  }
}
----
<.> Talk to the `/users` endpoint to determine authenticated status. A username will be returned if the user is logged in.
<.> When the user clicks a login button, redirect them to a Spring Security endpoint to do the OAuth dance.
<.> Logout using the `/api/logout` endpoint, which returns the Okta Logout API URL and a valid ID token.
====

Create a `user.ts` file in the same directory, to hold your `User` model.

[source,typescript]
.notes/src/app/shared/user.ts
----
export class User {
  sub: number;
  fullName: string;
}
----

Update `app.component.ts` to use your new `AuthService` in favor of `OktaAuthService`.

[source,typescript]
.notes/src/app/app.component.ts
----
import { Component, OnInit } from '@angular/core';
import { AuthService } from './shared/auth.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit {
  title = 'Notes';
  isAuthenticated: boolean;
  isCollapsed = true;

  constructor(public auth: AuthService) {
  }

  async ngOnInit() {
    this.isAuthenticated = await this.auth.isAuthenticated();
    this.auth.$authenticationState.subscribe(
      (isAuthenticated: boolean)  => this.isAuthenticated = isAuthenticated
    );
  }
}
----

Remove `OktaAuthModule` and its related code from `app.component.spec.ts` and `home.component.spec.ts`. You'll also need to add `HttpClientTestingModule` to their `TestBed` imports.

Change the buttons in `app.component.html` to reference the `auth` service instead of `oktaAuth`.

[source,html]
.notes/src/app/app.component.html
----
<button *ngIf="!isAuthenticated" (click)="auth.login()"
        class="btn btn-outline-primary" id="login">Login</button>
<button *ngIf="isAuthenticated" (click)="auth.logout()"
        class="btn btn-outline-secondary" id="logout">Logout</button>
----

Update `home.component.ts` to use `AuthService` too.

[source,typescript]
.notes/src/app/home/home.component.ts
----
import { Component, OnInit } from '@angular/core';
import { AuthService } from '../shared/auth.service';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.scss']
})
export class HomeComponent implements OnInit {
  isAuthenticated: boolean;

  constructor(public auth: AuthService) {
  }

  async ngOnInit() {
    this.isAuthenticated = await this.auth.isAuthenticated();
  }
}
----

Delete `notes/src/app/auth-routing.module.ts` and `notes/src/app/shared/okta`.

Modify `app.module.ts` to remove the `AuthRoutingModule` import, add `HomeComponent` as a declaration, and import `HttpClientModule`.

[source,typescript]
.notes/src/app/app.module.ts
----
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { NoteModule } from './note/note.module';
import { NgbModule } from '@ng-bootstrap/ng-bootstrap';
import { HomeComponent } from './home/home.component';
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    HttpClientModule,
    NoteModule,
    NgbModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
----

Add the route for `HomeComponent` to `app-routing.module.ts`.

[source,typescript]
.notes/src/app/app-routing.module.ts
----
import { HomeComponent } from './home/home.component';

const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  {
    path: 'home',
    component: HomeComponent
  }
];
----

Change both `environments.ts` and `environments.prod.ts` to use a blank `apiUrl`.

[source,typescript]
----
apiUrl: ''
----

Create a `proxy.conf.js` file to proxy certain requests to your Spring Boot API on `\http://localhost:8080`.

[source,javascript]
.notes/src/proxy.conf.js
----
const PROXY_CONFIG = [
  {
    context: ['/user', '/api', '/oauth2', '/login'],
    target: 'http://localhost:8080',
    secure: false,
    logLevel: 'debug'
  }
]

module.exports = PROXY_CONFIG;
----

Add this file as a `proxyConfig` option in `angular.json`.

[source,json]
.notes/angular.json
----
"serve": {
  "builder": "@angular-devkit/build-angular:dev-server",
  "options": {
    "browserTarget": "notes:build",
    "proxyConfig": "src/proxy.conf.js"
  },
  ...
},
----

Remove Okta's Angular SDK and OktaDev Schematics from your Angular project.

[source,shell]
----
npm uninstall @okta/okta-angular @oktadev/schematics
----

At this point, your Angular app doesn't contain any Okta-specific code for authentication. Instead, it relies  on your Spring Boot app to provide that.

You should still be able to run `ng serve` in your Angular app and `./gradlew bootRun` in your Spring Boot app for local development. However, you'll need to make some adjustments to your Spring Boot app to include Angular for production.

=== Configure Spring Boot to Include Your Angular SPA

In your Spring Boot app, you'll need to change a number of things. You'll need to configure Gradle to build your Angular app when you pass in `-Pprod`, you'll need to adjust its routes (so it's SPA-aware and routes all 404s to `index.html`), and you'll need to modify Spring Security to allow HTML, CSS, and JavaScript to be anonymously accessed.

To begin, delete `src/main/kotlin/com/okta/developer/notes/HomeController.kt`. You'll no longer need this because your Angular app will be served up at the `/` path.

Next, create a `RouteController.kt` that routes all requests to `index.html`.

[source,kotlin]
.notes-api/src/main/kotlin/com/okta/developer/notes/RouteController.kt
----
package com.okta.developer.notes

import org.springframework.stereotype.Controller
import org.springframework.web.bind.annotation.RequestMapping
import javax.servlet.http.HttpServletRequest

@Controller
class RouteController {

    @RequestMapping(value = ["/{path:[^\\.]*}"])
    fun redirect(request: HttpServletRequest): String {
        return "forward:/"
    }
}
----

Modify `SecurityConfiguration.kt` to allow anonymous access to static web files, the `/user` info endpoint, and to add additional security headers.

[source,kotlin]
.notes-api/src/main/kotlin/com/okta/developer/notes/SecurityConfiguration.kt
----
package com.okta.developer.notes

import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
import org.springframework.security.web.csrf.CookieCsrfTokenRepository
import org.springframework.security.web.header.writers.ReferrerPolicyHeaderWriter
import org.springframework.security.web.util.matcher.RequestMatcher

@EnableWebSecurity
class SecurityConfiguration : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        //@formatter:off
        http
            .authorizeRequests()
                .antMatchers("/**/*.{js,html,css}").permitAll()
                .antMatchers("/", "/user").permitAll()
                .anyRequest().authenticated()
                .and()
            .oauth2Login()
                .and()
            .oauth2ResourceServer().jwt()

        http.requiresChannel()
                .requestMatchers(RequestMatcher {
                    r -> r.getHeader("X-Forwarded-Proto") != null
                }).requiresSecure()

        http.csrf()
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())

        http.headers()
                .contentSecurityPolicy("script-src 'self'; report-to /csp-report-endpoint/")
                .and()
                .referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.SAME_ORIGIN)
                .and()
                .featurePolicy("accelerometer 'none'; camera 'none'; microphone 'none'")

        //@formatter:on
    }
}
----

TIP: See https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers[Spring Security's headers] documentation to see default security headers and other options.

With Kotlin, you can mark parameters and return values as optional by adding `?` to their type. Update the `user()` method in `UserController.kt` to make `OidcUser` optional. It will be `null` when the user is not authenticated, that's why this change is needed.

[source,kotlin]
.notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
----
@GetMapping("/user")
fun user(@AuthenticationPrincipal user: OidcUser?): OidcUser? {
    return user;
}
----

Previously, Angular handled logout. Add a `LogoutController` that will handle expiring the session as well as sending information back to Angular so it can logout from Okta.

[source,kotlin]
.notes-api/src/main/kotlin/com/okta/developer/notes/LogoutController.kt
----
package com.okta.developer.notes

import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.client.registration.ClientRegistration
import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository
import org.springframework.security.oauth2.core.oidc.OidcIdToken
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RestController
import javax.servlet.http.HttpServletRequest

@RestController
class LogoutController(val clientRegistrationRepository: ClientRegistrationRepository) {

    val registration: ClientRegistration = clientRegistrationRepository.findByRegistrationId("okta");

    @PostMapping("/api/logout")
    fun logout(request: HttpServletRequest,
               @AuthenticationPrincipal(expression = "idToken") idToken: OidcIdToken): ResponseEntity<*> {
        val logoutUrl = this.registration.providerDetails.configurationMetadata["end_session_endpoint"]
        val logoutDetails: MutableMap<String, String> = HashMap()
        logoutDetails["logoutUrl"] = logoutUrl.toString()
        logoutDetails["idToken"] = idToken.tokenValue
        request.session.invalidate()
        return ResponseEntity.ok().body<Map<String, String>>(logoutDetails)
    }
}
----

NOTE: In link:/blog/2020/03/27/spring-oidc-logout-options[OpenID Connect Logout Options with Spring Boot], Brian Demers describes this as RP-Initiated Logout. He also shows how you can configure Spring Security's `OidcClientInitiatedLogoutSuccessHandler` to logout. I tried this technique but decided against it because it doesn't allow me to redirect back to my Angular app in dev mode. I also encountered some CORS errors that I was unable to solve.

When you access the `/user/notes` endpoint with Angular, the `${principal.name}` expression correctly resolves to the user's email. However, when you access this endpoint after logging in directly to Spring Boot, it resolves to the `sub` claim. To make these values consistent, add the following property to `application-dev.properties` and `application-prod.properties`.

[source,properties]
----
spring.security.oauth2.client.provider.okta.user-name-attribute=preferred_username
----

You can also remove the `allowed.origins` property from both files since Angular will proxy the request in development (eliminating the need for CORS) and there won't be cross-domain requests in production.

Add a `server.port` property to `application-prod.properties` that uses a `PORT` environment variable, if it's set.

[source,properties]
----
server.port=${PORT:8080}
----

Because there won't be any cross-domain requests, you can remove the `simpleCorsFilter` bean and `allowedOrigins` variable in `DemoApplication.kt`, too.

=== Modify Gradle to Build a JAR with Angular Included

Now that your Spring Boot app is ready to serve up your Angular app, you need to modify your Gradle configuration to build your Angular app and package it in the JAR.

Start by importing `NpmTask` and adding the Node Gradle plugin.

[source,kotlin]
.notes/build.gradle.kts
----
import com.moowork.gradle.node.npm.NpmTask

plugins {
    ...
    id("com.github.node-gradle.node") version "2.2.4"
    ...
}
----

Then, define the location of your Angular app and configuration for the Node plugin.

[source,kotlin]
----
val spa = "${projectDir}/../notes";

node {
    version = "12.16.2"
    nodeModulesDir = file(spa)
}
----

Add a `buildWeb` task:

[source,kotlin]
----
val buildWeb = tasks.register<NpmTask>("buildNpm") {
    dependsOn(tasks.npmInstall)
    setNpmCommand("run", "build")
    setArgs(listOf("--", "--prod"))
    inputs.dir("${spa}/src")
    inputs.dir(fileTree("${spa}/node_modules").exclude("${spa}/.cache"))
    outputs.dir("${spa}/dist")
}
----

And modify the `processResources` task to build Angular when `-Pprod` is passed in.

[source,kotlin]
----
tasks.processResources {
    rename("application-${profile}.properties", "application.properties")
    if (profile == "prod") {
        dependsOn(buildWeb)
        from("${spa}/dist/notes") {
            into("static")
        }
    }
}
----

Now you should be able to combine both apps using `./gradlew bootJar -Pprod`. Once it's built, run it with the following commands to ensure everything works.

[source,shell]
----
docker-compose -f src/main/docker/postgresql.yml up -d
source okta.env
java -jar build/libs/*.jar
----

Congrats! You modified your Angular and Spring Boot apps to be packaged together and implemented the most secure form of OAuth 2.0 to boot! 🎊

Commit your changes to Git.

[source,shell]
----
git add .
git commit -m "Combine Angular and Spring Boot"
----

== Dockerize Angular + Spring Boot with Jib

Since everything is done via Gradle now, you can use plugins to build a Docker container. https://github.com/GoogleContainerTools/jib[Jib] builds optimized Docker images without the need for deep mastery of Docker best-practices. It reads your Gradle/Maven build files for its metadata.

To add Jib support, add its Gradle plugin.

[source,kotlin]
.notes/build.gradle.kts
----
plugins {
    ...
    id("com.google.cloud.tools.jib") version "2.4.0"
}
----

Then, at the end of this file, add `jib` configuration to specify your image name and the active Spring profile.

[source,kotlin]
----
jib {
    to {
        image = "<your-username>/bootiful-angular"
    }
    container {
        environment = mapOf("SPRING_PROFILES_ACTIVE" to profile)
    }
}
----

Run the following command to build a Docker image with Jib.

[source,shell]
----
./gradlew jibDockerBuild -Pprod
----

TIP: If you want to override the image name in `build.gradle.kts`, you can pass in an `--image` parameter. For example, `./gradlew jibDockerBuild -Pprod --image=bootiful-ng9`.

=== Run Your Spring Boot Docker App with Docker Compose

In theory, you should be able to run the following command to run your app.

[source,shell]
----
docker run --publish=8080:8080 <your-username>/bootiful-angular
----

However, Spring Boot won't start because you haven't configured the Okta environment variables. You could pass them in on the command line, but it's easier to specify them in a file.

You can https://docs.docker.com/compose/compose-file/#env_file[use Docker Compose and its `env_file` option] to specify environment variables.

Copy `notes-api/okta.env` to `src/main/docker/.env`.

Remove `export` at the beginning of each line. It should resemble something like the following after this change:

[source,shell]
----
OKTA_OAUTH2_ISSUER=https://dev-210914.okta.com/oauth2/default
OKTA_OAUTH2_CLIENT_ID=0oaa7psy...
OKTA_OAUTH2_CLIENT_SECRET=FJcSFpTC6N...
----

Create a `src/main/docker/app.yml` file that configures your app to set environment variables and leverages your existing PostgreSQL container. Make sure to replace the `<your-username>` placeholder and make the image match what's in your `build.gradle.kts` file.

[source,yaml]
----
version: '2'
services:
  boot-app:
    image: <your-username>/bootiful-angular
    environment:
      - SPRING_DATASOURCE_URL=jdbc:postgresql://notes-postgresql:5432/notes
      - OKTA_OAUTH2_ISSUER=${OKTA_OAUTH2_ISSUER}
      - OKTA_OAUTH2_CLIENT_ID=${OKTA_OAUTH2_CLIENT_ID}
      - OKTA_OAUTH2_CLIENT_SECRET=${OKTA_OAUTH2_CLIENT_SECRET}
    ports:
      - 8080:8080
    depends_on:
      - notes-postgresql
  notes-postgresql:
    extends:
      file: postgresql.yml
      service: notes-postgresql
----

Docker Compose expects the `.env` file to be in the directory you run `docker-compose` from, so you have two choices:

1. Navigate to the `src/main/docker` directory before running `docker-compose`
2. Create a symlink to `.env` in your root directory: `ln -s src/main/docker/.env`

If you choose option #1, run:

[source,shell]
----
cd src/main/docker
docker-compose -f app.yml up
----

Option #2 looks like:

[source,shell]
----
docker-compose -f src/main/docker/app.yml up
----

Once you've verified everything works, commit your changes to Git.

[source,shell]
----
git add .
git commit -m "Add Jib to build Docker images"
----

=== Deploy Your Spring Boot + Angular Container to Docker Hub

Jib makes it incredibly easy to deploy your container to Docker Hub. If you don't already have a Docker Hub account, you can https://hub.docker.com/signup[create one].

Run `docker login` to log into your account, then use the `jib` task to build *and* deploy your image.

[source,shell]
----
./gradlew jib -Pprod
----

Isn't it cool how Jib makes it so you don't need a `Dockerfile`!? 👍

== Heroku 💜 Spring Boot + Docker

To deploy this container to Heroku, create a new Heroku app and add it as a Git remote.

[source,shell]
----
heroku create
git remote add jib https://git.heroku.com/<your-new-app>.git
----

At this point, you can use the PostgreSQL and Okta add-ons you've already configured. If you'd like to do this, use `addons:attach` instead of `addons:create` in the following commands. Since both add-ons are free, I'm just going to show how to create new ones.

Add PostgreSQL to this app and configure it for Spring Boot using the following commands:

[source,shell]
----
heroku addons:create heroku-postgresql --remote jib
heroku config:get DATABASE_URL --remote jib
heroku config:set SPRING_DATASOURCE_URL=jdbc:postgresql://<value-after-@-from-last-command> --remote jib
heroku config:set SPRING_DATASOURCE_USERNAME=<username-value-from-last-command> --remote jib
heroku config:set SPRING_DATASOURCE_PASSWORD=<password-value-from-last-command> --remote jib
heroku config:set SPRING_DATASOURCE_DRIVER_CLASS_NAME=org.postgresql.Driver --remote jib
----

NOTE: This fine-grained configuration is not necessary when you use Heroku's buildpacks to deploy your Spring Boot app. It injects scripts that set `SPRING_*` environment variables for you. In this case, Heroku doesn't know you're using Spring Boot since it's running in a container.

Add Okta to your app.

[source,shell]
----
heroku addons:create okta --remote jib
----

To see your database and Okta environment variables, run:

[source,shell]
----
heroku config --remote jib
----

Modify the Okta environment variables to remove the `_WEB` on the two keys that have it.

[source,shell]
----
heroku config:edit --remote jib
----

Run the commands below to deploy the image you deployed to Docker Hub. Be sure to replace the `<...>` placeholders with your username and app name.

[source,shell]
----
docker tag <your-username>/bootiful-angular registry.heroku.com/<heroku-app>/web
docker push registry.heroku.com/<heroku-app>/web
heroku container:release web --remote jib
----

For example, I used:

[source,shell]
----
docker tag mraible/bootiful-angular registry.heroku.com/enigmatic-woodland-19325/web
docker push registry.heroku.com/enigmatic-woodland-19325/web
heroku container:release web --remote jib
----

You can watch the logs to see if your container started successfully.

[source,shell]
----
heroku logs --tail --remote jib
----

Once you've verified it has started OK, set the Hibernate configuration so it only validates the schema.

[source,shell]
----
heroku config:set SPRING_JPA_HIBERNATE_DDL_AUTO=validate --remote jib
----

Since the Okta Add-on for Heroku configures everything for you, you should be able to open your app, click the **Login** button, and authenticate!

[source,shell]
----
heroku open --remote jib
----

If you test your Dockerfied Angular + Spring Boot app on securityheaders.com, you'll see it scores an **A+**!

image::{% asset_path 'blog/angular-docker/heroku-jib-headers-a+.png' %}[alt=A+ Security Headers,width=800,align=center]

== Knative 💙 Spring Boot + Docker

Heroku is awesome, but sometimes people want more control over their infrastructure. Enter Knative. It's like Heroku in that it's a Platform as a Service (PaaS). Knative is built on top of Kubernetes so you can install a number of services with a bit of YAML and `kubectl` commands.

With Heroku, when companies reach the limitations of the platform, they have to go elsewhere to host their services. With Knative, you can just drop down to Kubernetes. It's Heroku for Kubernetes in a sense, but you don't have to switch to a different universe when you need additional functionality.

The https://knative.dev/[Knative website] says it'll make your developers more productive.

> Knative components build on top of Kubernetes, abstracting away the complex details and enabling developers to focus on what matters. Built by codifying the best practices shared by successful real-world implementations, Knative solves the "boring but difficult" parts of deploying and managing cloud native services, so you don't have to.

You'll need a Google Cloud account for this section. Go to https://cloud.google.com/[cloud.google.com] and click **Get started for free**.

Once you have an account, go to https://console.cloud.google.com/[Google Cloud Console] and create a new project.

Then, click on the Terminal icon in the top right to open a Cloud Shell terminal for your project.

Enable Cloud and Container APIs:

[source,shell]
----
gcloud services enable \
  cloudapis.googleapis.com \
  container.googleapis.com \
  containerregistry.googleapis.com
----

NOTE: This command can take a minute or two to complete.

When it's done, set your default zone and region:

[source,shell]
----
gcloud config set compute/zone us-central1-c
gcloud config set compute/region us-central1
----

And create a Kubernetes cluster:

[source,shell]
----
gcloud beta container clusters create knative \
  --addons=HorizontalPodAutoscaling,HttpLoadBalancing \
  --machine-type=n1-standard-4 \
  --cluster-version=1.15 \
  --enable-stackdriver-kubernetes --enable-ip-alias \
  --enable-autoscaling --min-nodes=5 --num-nodes=5 --max-nodes=10 \
  --enable-autorepair \
  --scopes cloud-platform
----

_You can safely ignore the warnings that result from running this command._

Next, set up a cluster administrator and install Istio.

[source,shell]
----
kubectl create clusterrolebinding cluster-admin-binding \
  --clusterrole=cluster-admin \
  --user=$(gcloud config get-value core/account)

kubectl apply -f \
https://github.com/knative/serving/raw/v0.14.0/third_party/istio-1.5.1/istio-crds.yaml

while [[ $(kubectl get crd gateways.networking.istio.io -o jsonpath='{.status.conditions[?(@.type=="Established")].status}') != 'True' ]]; do
  echo "Waiting on Istio CRDs"; sleep 1
done

kubectl apply -f \
https://github.com/knative/serving/raw/v0.14.0/third_party/istio-1.5.1/istio-minimal.yaml
----

Now, you should be able to install Knative!

[source,shell]
----
kubectl apply --selector knative.dev/crd-install=true -f \
 https://github.com/knative/serving/releases/download/v0.14.0/serving.yaml

kubectl apply -f \
 https://github.com/knative/serving/releases/download/v0.14.0/serving.yaml

while [[ $(kubectl get svc istio-ingressgateway -n istio-system \
  -o 'jsonpath={.status.loadBalancer.ingress[0].ip}') == '' ]]; do
  echo "Waiting on external IP"; sleep 1
done
----

You'll need a domain to enable HTTPS, so set that up and point it to the cluster's IP address.

[source,shell]
----
export IP_ADDRESS=$(kubectl get svc istio-ingressgateway -n istio-system \
  -o 'jsonpath={.status.loadBalancer.ingress[0].ip}')
echo $IP_ADDRESS

kubectl apply -f - <<EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: config-domain
  namespace: knative-serving
data:
  $IP_ADDRESS.nip.io: ""
EOF
----

Install https://cert-manager.io/[cert-manager] to automatically provision and manage TLS certificates in Kubernetes.

[source,shell]
----
kubectl apply --validate=false -f \
 https://github.com/jetstack/cert-manager/releases/download/v0.14.3/cert-manager.yaml

kubectl wait --for=condition=Available -n cert-manager deployments/cert-manager-webhook
----

And configure free TLS certificate issuing with https://letsencrypt.org/[Let's Encrypt].

[source,shell]
----
kubectl apply -f - <<EOF
apiVersion: cert-manager.io/v1alpha2
kind: ClusterIssuer
metadata:
  name: letsencrypt-http01-issuer
spec:
  acme:
    privateKeySecretRef:
      name: letsencrypt
    server: https://acme-v02.api.letsencrypt.org/directory
    solvers:
    - http01:
       ingress:
         class: istio
EOF

kubectl apply -f \
https://github.com/knative/serving/releases/download/v0.14.0/serving-cert-manager.yaml

kubectl apply -f - <<EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: config-certmanager
  namespace: knative-serving
data:
  issuerRef: |
    kind: ClusterIssuer
    name: letsencrypt-http01-issuer
EOF

kubectl apply -f - <<EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: config-network
  namespace: knative-serving
data:
  autoTLS: Enabled
  httpProtocol: Enabled
EOF
----

_Phew!_ That was a lot of `kubectl` and YAML, don't you think?! The good news is you're ready to deploy PostgreSQL and your Spring Boot app.

The following command can deploy everything, but you'll need to change the `<...>` placeholders to match your values first.

[source,shell]
----
kubectl apply -f - <<EOF
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pgdata
  annotations:
    volume.alpha.kubernetes.io/storage-class: default
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 1Gi
---
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: postgres
spec:
  replicas: 1
  template:
    metadata:
      labels:
        service: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:10.1
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              value: bootiful-angular
            - name: POSTGRES_USER
              value: bootiful-angular
            - name: POSTGRES_PASSWORD
              value: <your-db-password>
          volumeMounts:
            - mountPath: /var/lib/postgresql/data
              name: pgdata
              subPath: data
      volumes:
        - name: pgdata
          persistentVolumeClaim:
            claimName: pgdata
---
apiVersion: v1
kind: Service
metadata:
  name: pgservice
spec:
  ports:
  - port: 5432
    name: pgservice
  clusterIP: None
  selector:
    service: postgres
---
apiVersion: serving.knative.dev/v1alpha1
kind: Service
metadata:
  name: bootiful-angular
spec:
  template:
    spec:
      containers:
        - image: <your-username>/bootiful-angular
          env:
          - name: SPRING_DATASOURCE_URL
            value: jdbc:postgresql://pgservice:5432/bootiful-angular
          - name: SPRING_DATASOURCE_USERNAME
            value: bootiful-angular
          - name: SPRING_DATASOURCE_PASSWORD
            value: <your-db-password>
          - name: OKTA_OAUTH2_ISSUER
            value: <your-okta-issuer>
          - name: OKTA_OAUTH2_CLIENT_ID
            value: <your-okta-client-id>
          - name: OKTA_OAUTH2_CLIENT_SECRET
            value: <your-okta-client-secret>
EOF
----

Once the deployment has completed, run the command below to change it so Hibernate doesn't try to recreate your schema on restart.

[source,shell]
----
kubectl apply -f - <<EOF
apiVersion: serving.knative.dev/v1alpha1
kind: Service
metadata:
  name: bootiful-angular
spec:
  template:
    spec:
      containers:
        - image: <your-username>/bootiful-angular
          env:
          - name: SPRING_DATASOURCE_URL
            value: jdbc:postgresql://pgservice:5432/bootiful-angular
          - name: SPRING_DATASOURCE_USERNAME
            value: bootiful-angular
          - name: SPRING_DATASOURCE_PASSWORD
            value: <your-db-password>
          - name: OKTA_OAUTH2_ISSUER
            value: <your-okta-issuer>
          - name: OKTA_OAUTH2_CLIENT_ID
            value: <your-okta-client-id>
          - name: OKTA_OAUTH2_CLIENT_SECRET
            value: <your-okta-client-secret>
          - name: SPRING_JPA_HIBERNATE_DDL_AUTO
            value: validate
EOF
----

If everything works correctly, you should be able to run the following command to get the URL of your app.

[source,shell]
----
kubectl get ksvc bootiful-angular
----

The result should look similar to this:

[source,shell]
----
NAME               URL                                                    LATESTCREATED            LATESTREADY              READY   REASON
bootiful-angular   https://bootiful-angular.default.34.70.42.153.nip.io   bootiful-angular-qf9hn   bootiful-angular-qf9hn   True
----

You'll need to add this URL (+ `/login/oauth2/code/okta`) as a **Login redirect URI** and a **Logout redirect URI** in Okta in order to log in.

image::{% asset_path 'blog/angular-docker/knative-login-logout-uris.png' %}[alt=Knative Login and Logout URIs,width=700,align=center]

Then, you'll be able to log into your app running on Knative! Add a note or two to prove it all works.

image::{% asset_path 'blog/angular-docker/knative-works.png' %}[alt=Angular + Spring Boot in Docker running on Knative,width=800,align=center]

== Cloud Foundry 💚 Spring Boot + Docker

Did you know you can https://docs.cloudfoundry.org/adminguide/docker.html[run Docker containers on Cloud Foundry]? It's pretty slick.

If you'd like to test it out, you'll need a https://run.pivotal.io/[Pivotal Web Services] account. You'll also need to install the https://docs.cloudfoundry.org/cf-cli/install-go-cli.html[Cloud Foundry CLI]. If you're using Homebrew, you can use `brew install cloudfoundry/tap/cf-cli`.

Apps deployed to Cloud Foundry (CF) with the `cf push` command run in standard CF Linux containers. With Docker support enabled, CF can also deploy and manage apps running in Docker containers.

Then, where `secure-notes` is a unique name for your app, run the following commands.

[source,shell]
----
cf login

# Deploy the image from Docker Hub
cf push --no-start -o <your-username>/bootiful-angular secure-notes

# Create a PostgreSQL instance
cf cs elephantsql turtle secure-notes-psql

# Bind the app to the PostgreSQL instance
cf bs secure-notes secure-notes-psql
----

At this point, you'll need to set a number of environment variables so your app can connect to PostgreSQL and Okta. Substitute your values in the `<...>` placeholders before running the command below.

To get your PostgreSQL URL run the following command where `secure-notes` is your app name.

[source,shell]
----
cf env secure-notes
----

You will see a `uri` at the top of the output that has the URL you'll need to parse and set as variables below. Make sure to replace `postgres://` with `jdbc:postgresql://` at the beginning of the datasource URL and extract the credentials for the username and password settings.

[source,shell]
----
export APP_NAME=<your-app-name>
cf set-env $APP_NAME SPRING_DATASOURCE_DRIVER_CLASS_NAME org.postgresql.Driver
cf set-env $APP_NAME SPRING_DATASOURCE_URL <postgresql-jdbc-url>
cf set-env $APP_NAME SPRING_DATASOURCE_USERNAME <postgresql-username>
cf set-env $APP_NAME SPRING_DATASOURCE_PASSWORD <postgresql-passord>
cf set-env $APP_NAME OKTA_OAUTH2_ISSUER <your-okta-issuer>
cf set-env $APP_NAME OKTA_OAUTH2_CLIENT_ID <your-okta-client-id>
cf set-env $APP_NAME OKTA_OAUTH2_CLIENT_SECRET <your-okta-client-id>
cf restage $APP_NAME
----

Your app, running in Docker, should now be available at `\http://<your-app-name>.cfapps.io`.

You'll need to add this URL (+ `/login/oauth2/code/okta`) as a **Login redirect URI** and **Logout redirect URI** on Okta in order to log in.

You'll also want to configure JPA so it doesn't recreate the schema on each restart.

[source,shell]
----
cf set-env $APP_NAME SPRING_JPA_HIBERNATE_DDL_AUTO validate
----

Now you should be able to loginlog in and add notes to your heart's content!

image::{% asset_path 'blog/angular-docker/cloud-foundry-works.png' %}[alt=Angular + Spring Boot in Docker running on Pivotal Web Services,width=800,align=center]

You can also just use a `manifest.yml` to make it so you don't have to type all the commands above.

[source,yaml]
----
applications:
- name: <your-app-name>
  disk_quota: 1G
  docker:
    image: <your-username>/bootiful-angular
  env:
    OKTA_OAUTH2_CLIENT_ID: <your-okta-client-id>
    OKTA_OAUTH2_CLIENT_SECRET: <your-okta-client-secret>
    OKTA_OAUTH2_ISSUER: <your-okta-issuer>
    SPRING_DATASOURCE_DRIVER_CLASS_NAME: org.postgresql.Driver
    SPRING_DATASOURCE_PASSWORD: <postgresql-password>
    SPRING_DATASOURCE_URL: <postgresql-jdbc-url>
    SPRING_DATASOURCE_USERNAME: <postgresql-username>
instances: 1
  memory: 1G
  routes:
    - route: http://<your-app-name>.cfapps.io
  services:
    - <your-app-name>-psql
  stack: cflinuxfs3
----

Since most of these environment variables should probably be externally specified, it's not much gain to use the `manifest.yml` in this case. Storing secrets in source control is a bad idea!

CAUTION: If you do decide to store everything in `manifest.yml`, make sure to add it to `.gitignore`.

With a `manifest.yml` in place, you can simply run `cf push` and it'll do the same thing as the aforementioned `cf` commands.

== Use Cloud Native Buildpacks to Build Docker Images

https://buildpacks.io/[Cloud Native Buildpacks] is an initiative that was started by Pivotal and Heroku in early 2018. It has a https://github.com/buildpacks/pack[`pack` CLI] that allows you to build Docker images using buildpacks.

Unfortunately, `pack` doesn't have great support for monorepos (especially in sub-directories) yet. I was unable to make it work with this app structure.

On the upside, Spring Boot 2.3's built-in support for creating Docker images works splendidly!

== Easy Docker Images with Spring Boot 2.3

https://spring.io/blog/2020/05/15/spring-boot-2-3-0-available-now[Spring Boot 2.3.0 is now available] and with it comes built-in Docker support. It leverages Cloud Native Buildpacks, just like the `pack` CLI.

Spring Boot's Maven and Gradle plugins both have new commands:

- `./mvnw spring-boot:build-image`
- `./gradlew bootBuildImage`

The https://paketo.io/[Paketo] Java buildpack is used by default to create images.

TIP: Learn more in https://twitter.com/phillip_webb[Phil Webb's] blog post: https://spring.io/blog/2020/01/27/creating-docker-images-with-spring-boot-2-3-0-m1[Creating Docker images with Spring Boot 2.3.0.M1] or his excellent https://spring.io/blog/2020/06/18/what-s-new-in-spring-boot-2-3[What's new in Spring Boot 2.3 video].

By default, Spring Boot will use your `$artifactId:$version` for the image name. That is, `notes-api:0.0.1-SNAPSHOT`. You can override this with an `--imageName` parameter.

Build and run the image with the commands below.

[source,shell]
----
./gradlew bootBuildImage --imageName <your-username>/bootiful-angular -Pprod
docker-compose -f src/main/docker/app.yml up
----

You should be able to navigate to `http://localhost:8080`, log in, and add notes.

image::{% asset_path 'blog/angular-docker/spring-boot-2.3-notes.png' %}[alt=Spring Boot 2.3 app running,width=800,align=center]

Pretty neat, don't you think!? 😃

== Learn More About Angular, Spring Boot, and Docker

This lengthy tutorial showed you a lot of options when it comes to deploying your Angular and Spring Boot apps with Docker:

* Build Angular containers with `Dockerfile`
* Combine Angular and Spring Boot in a JAR
* Build Docker images with Jib
* Build Docker images with Buildpacks

You can find the source code for this example on GitHub at https://github.com/oktadeveloper/okta-angular-spring-boot-docker-example[oktadeveloper/okta-angular-spring-boot-docker-example].

As a developer, you probably don't want to do a series of tutorials to get to a baseline to start a project. The good news is https://jhipster.tech[JHipster] does everything in this series. It allows you to run your Angular and Spring Boot apps separately, use Kotlin on the server, package your apps together for production, and use Docker for distribution.

To learn more about Angular, Spring Boot, and Docker, see some of our other blog posts.

- link:/blog/2020/01/06/crud-angular-9-spring-boot-2[Build a CRUD App with Angular 9 and Spring Boot 2.2]
- link:/blog/2020/03/02/angular-bootstrap[Build Beautiful Angular Apps with Bootstrap]
- https://developer.okta.com/blog/2019/10/30/java-oauth2[OAuth 2.0 Java Guide: Secure Your App in 5 Minutes]
- https://developer.okta.com/blog/2019/08/09/jib-docker-spring-boot[Get Jibby With Java, Docker, and Spring Boot]
- https://developer.okta.com/blog/2017/10/11/developers-guide-to-docker-part-3[A Developer's Guide To Docker - Docker Compose]

https://twitter.com/oktadev[Follow @oktadev on Twitter] for more posts like this one. We also have a https://youtube.com/c/oktadev[YouTube channel] you might enjoy. As always, please leave a comment below if you have any questions!
